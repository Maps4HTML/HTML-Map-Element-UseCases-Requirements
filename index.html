<!DOCTYPE html>
<html lang="en">
<head>
<meta charset='utf-8'>
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Use Cases and Requirements for Standardizing Web Maps</title>
<style>
h5:not(.specificity-hack) {
  margin-top: 2rem;
  margin-bottom: 1rem;
}
a:empty::before {
  content: attr(href);
}
[data-ucr-role="tag-dfn"]::after {
  content: " (" attr(id) ")";
  font-weight: normal;
  font-style: italic;
  margin-right: 0.3em;
}
dfn {
  font-weight: bold;
  font-style: inherit;
}
.tag-span {
  display: inline-block;
  font-style: normal;
  font-weight: bold;
  line-height: 1;
  padding: 0.3em 0.5em;
  border-radius: 0.5em;
  background-color: #ccc;
}
.tag-span.tag-bad {
  background-color: #f86;
}
.tag-span.tag-caution {
  background-color: #ff8;
}
.tag-span.tag-good {
  background-color: #8fa;
}
/* cancel out the fancy link styling on links
   that will contain solid-colored tags */
.processed a[href][data-ucr-role='tag'],
.processed a[href][data-ucr-role='conclusion'] {
  border-bottom: none;
  background: none;
}
/* add link styling on the tags instead */
a[href] .tag-span {
  color: black;
}
a[href]:hover .tag-span, a[href]:focus .tag-span {
  text-decoration: underline;
}
.issue .discussion {
  font-style: italic
}
.issue.discussion[data-number]::after {
  content: " (#" attr(data-number) ")";
  /* applies if ReSpec JS doesn't run */
}
[id^="use-case-"] figure img {
  border-radius: 2px;
  height: auto;
  max-width: 100%;
  margin: auto;
  margin-bottom: .5rem;
}
.figno::after {
  content: ":";
}
</style>
<script class='remove'>
var respecConfig = {
  // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
  specStatus:  "CG-DRAFT",

  // if your specification has a subtitle that goes below the main
  // formal title, define it here
  // subtitle:  "",

  // if you wish the publication date to be other than the last modification, set this
  // publishDate:  "1999-12-31",
  copyrightStart: "2019",

  github: "https://github.com/Maps4HTML/HTML-Map-Element-UseCases-Requirements",

  // if there a publicly available Editor's Draft, this is the link
  // (calculated automatically for GitHub pages)
  edDraftURI:  "https://maps4html.org/HTML-Map-Element-UseCases-Requirements/",

  // editors, add as many as you like
  // only "name" is required
  editors:  [
      {
          name:       "Amelia Bellamy-Royds",
          mailto:     "amelia.bellamy.royds@gmail.com"
      }
  ],
  authors:  [
      {
          name:       "Amelia Bellamy-Royds"
      },
      {
          name:       "Nic Chan"
      },
      {
          name:       "Nick Fitzsimons"
      },
      {
          name:       "Robert Linder"
      },
      {
          name:       "Peter Rushforth"
      },
  ],

  // name of the WG
  wg:           "Maps For HTML Community Group",

  // URI of the public WG page
  wgURI:        "https://www.w3.org/community/maps4html/",

  // name (without the @w3c.org) of the public mailing to which comments are due
  // wgPublicList: "public-maps4html", // don't use default comment request

  xref: false,
  localBiblio: {
    "webcomponents-design-guidelines" : {
      title: "Guidelines for creating web platform compatible components",
      href: "https://www.w3.org/2001/tag/doc/webcomponents-design-guidelines/",
      publisher: "W3C TAG"
    },
    "WGS84" : {
      title: "World Geodetic System 1984",
      href: "http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf",
      publisher: "US National Imagery and Mapping Agency"
    },
    "FAST" : {
      title: "Framework for Accessible Specification of Technologies",
      href: "https://w3c.github.io/apa/fast/",
      publisher: "W3C Accessible Platform Architectures Working Group (APA WG)"
    }
  }
};
respecConfig.otherLinks = [
  {
    key: 'Join the Community Group',
    data: [{value: respecConfig.wg, href: respecConfig.wgURI}]
  }
]
</script>
<script src='https://www.w3.org/Tools/respec/respec-w3c'
        defer class='remove'></script>
</head>
<body>
<section id='abstract'>
<p>
This report outlines the use cases and requirements
for standardizing modern Web maps,
in a way that works
for map content authors, webpage authors, and website users.
The use cases and requirements were gathered in
consultation with the Maps for HTML Community Group and others.
</p>
<p>
Three aspects of web maps are reviewed:
map viewer widgets,
client-side mapping APIs,
and
map data formats.
For each, evidence is gathered from widely-used scripted JavaScript web map frameworks.
The common features and limitations of the current techniques
are the basis of the requirements for a standardized solution
that could be built in to HTML and web browsers.
</section>

<section id='sotd'>
<p>
Comments, corrections, and suggested additions should be made as
<a href="https://github.com/Maps4HTML/HTML-Map-Element-UseCases-Requirements/issues/">GitHub issues</a>.
If that is not possible, send an email comment to
<a href="mailto:public-maps4html@w3.org">public-maps4html@w3.org</a>.
</p>
</section>

<section id="introduction">
<h2>Introduction</h2>

<section id="intro-web-maps">
<h3>The current state of web maps</h3>
<p>
Web maps today are indispensable to billions of people,
for exploring and understanding the world around them.
Like paper maps before them,
web maps are used for planning, wayfinding, analysis, and more.
But the power of an interactive, hyperlinked medium
supports a richer experience than could have been imagined
by a cartographer from a previous century.
Online maps can be dynamically redrawn with new data,
or according to the user's preferences.
They can connect to other maps —
for adjacent areas, finer detail, or different geographical features —
and can link out to complex information about the places they represent.
</p>
<p>
But despite their ubiquity on the web,
maps have no native, semantic representation in HTML.
</p>
<p>
HTML has had “image maps” —
hyperlinked graphics, where selecting different parts of the graphic triggers a different URL —
<a href="https://tools.ietf.org/html/rfc1866#section-7.6">from its early days</a>.
These were quickly adopted to
<a href="https://web.archive.org/web/20110628194820/http://www2.parc.com/istl/projects/www94/mapviewer.html">represent simple cartographic maps</a>.
The <a href="https://html.spec.whatwg.org/multipage/image-maps.html#the-map-element"><code>&lt;MAP&gt;</code></a> element
sounds like it should be the basis of a web map,
but its basic functionality
(to define geometric areas on an image that represent distinct hyperlinks)
has not evolved to include many capabilities
that users today expect when interacting with maps on the web,
such as the ability to dynamically change the map view.
</p>
<p>
Web mapping technology has undergone a <a href="https://en.wikipedia.org/wiki/Web_mapping#History_of_web_mapping">long period of evolution.</a>
Today's web maps are usually sophisticated client-server applications,
dynamically combining many types of spatial data on demand for web users.
Implementations vary widely,
but some of the underlying techniques, software, semantics and formats have become
accepted patterns
(for example, <a href="https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames">the tile naming systems</a>),
or formal standards
(for example, the <a href="https://www.opengeospatial.org/standards">standards published by the Open Geospatial Consortium</a>,
some of which are also ISO standards).
</p>
<p>
Many sources of spatial data are available online,
from governments, commercial services, and non-profit projects.
But accessing and using the data is a specialized task;
most web developers or website content creators
rely on JavaScript frameworks
(or sometimes still Flash frameworks)
that can fetch the correct map image tiles or vector data,
draw them to the screen,
and handle the most common user interactions.
</p>
<p>
Many of these web map frameworks are tied to a specific commercial provider of map data,
making it difficult for website creators to integrate their own data,
or data from multiple sources.
Many of the web map frameworks do not work at all without JavaScript,
and require considerable resource downloads and processing.
The end user has limited control or customization over the map interface —
unless the website author happened to choose the web map provider
that matches the native mapping application on the end-user's device.
</p>
<p>
Web maps today may not be perfect,
but they have filled a clear need for website authors and users.
The multiple frameworks used to generate web maps
implement the same capabilities with different code —
code that needs to be downloaded and processed for each website with a map in it.
These core aspects of Web maps represent mature, ubiquitous user interface (UI)
and application programming interface (API) patterns.
It is now reasonable to consider standardizing these capabilities
for implementation by web browsers directly.
</p>
<p>
A key challenge is to do so in a way that is
compatible with the core values of the open web,
and integrated with other web platform technologies.
</p>
</section>

<section id="intro-maps4html-cg">
<h3>The Maps for HTML Community Group</h3>
<p>
The Maps For HTML Community Group (<a href="https://www.w3.org/community/maps4html/">Maps4HTML</a>)
arose as a result of face-to-face
<a href="https://www.w3.org/community/maps4html/wiki/LGD14BarCampNotes">discussions</a>
at the Linking Geospatial Data workshop 2014,
co-sponsored by the W3C and the Open Geospatial Consortium.
</p>
<p>
The group operates within the structure of a W3C community group,
with clear license terms for contributions of intellectual property.
The community group process
designed to support the eventual transition of the group's work to become open web standards.
The group attempts to follow the established best practices for web standard development,
as outlined in <a href="#principles">the guiding principles</a> for this report.
</p>
<p>
The initial requirements sketched out at LGD2014
were expanded into <a href="draft-2015.html">an initial use cases and requirements summary</a>.
That work was the basis of the draft [[[MapML]]].
Although MapML has had notable support and development efforts
from within the geospatial community,
as of early 2019 it has not received significant support
from web browser developers or HTML standards teams.
For that reason, the current document rolls back the focus
to the discussion of mapping use cases and requirements.
The structure of this report is intended to more comprehensively explain
<em>why</em> native HTML web maps would be beneficial,
and <em>how</em> they should best be defined.
</p>
<div class="ednote">
<p>
This report is a work in progress!
Feedback and contributions are welcome.
Most sections of the report include links to a discussion issue on GitHub.
Use those issues to suggest corrections, additions,
or changes to the conclusions.
To suggest a new section (e.g., a new use case),
please start a new issue.
</p>
<p>
To make substantive contributions
(that is, anything that is bigger than typo corrections or formatting fixes),
you will need to first
<a href="https://www.w3.org/community/maps4html/">become a member of the community group</a>
and make the corresponding IP commitments.
</p>
</div>
</section>

<section id="intro-report-structure">
<h3>Structure of this report</h3>
<p>
The purpose of this report is to describe
(1) why and how the open web would benefit from having
web map features built in to web browsers,
and (2) what this native web mapping function should look like,
to website creators and to end users.
</p>
<p>
This report uses an empirical approach to identify required features of web maps,
by looking for the common features of web map frameworks used today.
However, we also recognize that web maps today have limitations.
A proposal for a native HTML web map, built in to web browsers,
needs to be assessed on the same merits as any other proposed web standard.
</p>
<p>
In <a href="#principles"></a>,
we outline the theoretical factors we use
for assessing whether a given feature should be included as a requirement.
</p>
<p>
In <a href="#use-cases"></a>,
we outline common goals for people interacting with web maps.
The use cases are defined in pragmatic terms,
describing a specific function or action.
Real-world, domain-specific applications of the use case
are summarized in an introductory description.
The use cases are divided according to whether they apply to
<a href="#content-author-use-cases">content creators</a>,
<a href="#visitor-use-cases">website visitors</a>,
or <a href="#application-use-cases">web application developers</a>.
(Of course, there is overlap between the audiences —
good developers want to create good user experiences!)
</p>
<p>
In <a href="#js-examples"></a>,
we introduce the web map frameworks that are used in the empirical review.
</p>
<p>
The review of potential requirements
is then divided into three parts:
</p>
<ul>
<li>
<a href="#map-viewers"></a>,
including the user interface
and all configuration that could be defined declaratively
in elements, attributes, and style properties.
</li>
<li>
<a href="#client-apis"></a>,
which would require additional DOM APIs
to enhance or complement the declarative elements.
</li>
<li>
<a href="#map-formats"></a>
that should be supported for representing spatial data
used by the map viewers.
</li>
</ul>
<p>
For each category, we list technological <dfn data-lt="capability">capabilities</dfn>:
features, which a web map might include, that could help solve the use cases.
Capabilities are potential requirements for a native HTML web map.
To assess whether the capability should be a requirement, we examine:
</p>
<dl>
<dt>Existing implementations</dt>
<dd>
How common is this capability in the reviewed JS web map frameworks?
Do they implement it with consistent, well-established patterns?
Are there any notable limitations of the current implementations,
when measured against the  <a href="#principles">principles of the inclusive web</a>?
</dd>
<dt>Supported use cases</dt>
<dd>
Which use cases are enabled by this capability?
</dd>
<dt>Uses beyond mapping</dt>
<dd>
Is there a demand for this capability on the web,
beyond its use in web mapping?
</dd>
<dt>Related web specifications</dt>
<dd>
How is this capability related to existing web standards
or proposed specifications?
Can the web map implementation build on existing features?
</dd>
</dl>
<p>
For each capability, we conclude by summarizing its costs and potential benefits
(using tags defined in the next section)
for integration as a native HTML web map feature.
We assign it one of three possible conclusions:
</p>
<dl>
<dt><dfn id="requirement" data-ucr-role="conclusion-dfn" data-ucr-tag-type="good">requirement</dfn></dt>
<dd>
The capability is essential for a native HTML web map implementation.
</dd>
<dt><dfn id="enhancement" data-ucr-role="conclusion-dfn" data-ucr-tag-type="caution">enhancement</dfn></dt>
<dd>
The capability would be nice to have in native HTML web maps,
but isn't necessary for the initial specification.
</dd>
<dt><dfn id="impractical" data-ucr-role="conclusion-dfn" data-ucr-tag-type="bad">impractical</dfn></dt>
<dd>
The capability isn't currently realistic for inclusion in native HTML web maps.
</dd>
</dl>
<p>
If there is not yet enough evidence for a conclusion,
the capability will be marked
<dfn id="undecided" data-ucr-role="conclusion-dfn">undecided</dfn>.
</p>
</section>

<section id="intro-glossary">
<h3>Glossary of key terms</h3>
<p>
Web mapping and geospatial data have a rich vocabulary
that is not always clear to outsiders.
This report uses the following terms in the ways defined here,
unless another meaning is clearly specified:
</p>
<dl>

<dt><dfn>map</dfn></dt>
<dd>
A graphical representation of the features of and spatial relationships between places.
Unless otherwise specified,
maps referred to in this report are assumed to be <a>geographic maps</a>
with a two-dimensional representation.
</dd>

<dt><dfn>geographic map</dfn></dt>
<dd>
A map of part (or all) of the surface of Earth (or another planet),
with a defined mathematical relationship between
positions on the map and geographical positions on the planet.
</dd>

<dt><dfn>non-geographic map</dfn></dt>
<dd>
A map in which positions on the graphic are not defined
relative to positions on the Earth's surface.
</dd>

<dt><dfn>interactive map</dfn></dt>
<dt><dfn>slippy map</dfn></dt>
<dd>
A map rendered as part of an interactive computer application,
such that the user of the app can manipulate aspects of the map display.
In particular, a slippy map is one in which
the user can pan the displayed map to view a different region.
</dd>

<dt><dfn>web map</dfn></dt>
<dd>
An interactive map integrated into a web page.
</dd>

<dt><dfn data-lt="GIS|geographic information system">geographic information system (GIS)</dfn></dt>
<dd>
A database system for managing geographic data (or other spatial data),
often including software for displaying the data as interactive maps.
</dd>

<dt><dfn>map server</dfn></dt>
<dd>
An internet-connected GIS,
that provides processed geographic data or map images
on request from client software (such as web browsers).
Map servers used by web maps are normally built on HTTP,
but many formats are used for search requests and data responses.
Some of these are described by formal standards,
others are defined only by the documentation of a particular map server.
</dd>

<dt><dfn data-lt="OWS|OGC Web Services|Open Geospatial Consortium Web Services">OGC Web Services (OWS)</dfn></dt>
<dd>
A set of <a href="https://www.opengeospatial.org/standards/">standards developed by the Open Geospatial Consortium (OGC)</a>
that define communication protocols between map servers and client software.
OWS standard define a format for exposing the available capabilities of the map server,
and for structuring requests for map data for a certain region,
possibly restricted by other search parameters.
The format of the returned map data is defined separately.
OWS standards include:
<ul>
  <li><dfn data-lt="Web Map Service|WMS">Web Map Service (WMS)</dfn>,
    for accessing a custom processed map image
    that directly represents the requested region and query parameters</li>
  <li><dfn data-lt="Web Map Tile Service|WMTS">Web Map Tile Service (WMTS)</dfn>,
    for accessing pre-processed map <a>tiles</a>,
    which may only represent a <a>layer</a> of the final map</li>
  <li><dfn data-lt="Web Feature Service|WFS">Web Feature Service (WFS)</dfn>,
    for accessing <a>vector feature</a> data</li>
  <li><dfn data-lt="Web Coverage Service|WCS">Web Coverage Service (WCS)</dfn>,
    for accessing raw <a>coverage</a> data</li>
  <li><dfn>OWS Context</dfn>,
    for returning metadata with references to other map services</li>
</ul>
</dd>

<dt><dfn>(map) projection</dfn></dt>
<dd>
A method of converting positions on the surface of a sphere (the Earth)
into positions in a 2D rendering (display screen or paper map).
All map projections involve some distortion of the data,
but different projections are preferred for different use cases.
<em>TODO: Figure comparing common map projections</em>
</dd>

<dt><dfn>coordinates</dfn></dt>
<dt><dfn>coordinate pair</dfn> or <dfn>coordinate triple</dfn></dt>
<dd>
A mathematical description of a particular location,
on a map (<dfn>map coordinates</dfn>)
or in reality (<dfn>geographic coordinates</dfn>).
Coordinates are generally defined as a pair or triple of measurements,
depending on whether the location they defining is in two dimensions
(e.g., a location on the surface of the Earth or position on a map)
or three dimensions.
</dd>

<dt><dfn data-lt="CRS|coordinate reference system">coordinate reference system (CRS)</dfn></dt>
<dd>
A standard way of defining map or geographic coordinates,
so that locations can be precisely compared or aligned
between different maps, map layers, or spatial data sets.
Some CRS are based on geographic coordinates,
while others are based on map coordinates
and therefore incorporate a map projection into their calculation.
</dd>

<dt><dfn>latitude</dfn> and <dfn>longitude</dfn></dt>
<dd>
Coordinate system for describing positions on the surface of the Earth.
Latitude values represent North-South distance from the equator.
Longitude values represent East-West distance from a reference line
(the prime meridian) that connects the poles.
Both values are angles, usually degrees.
Latitude and longitude are used in multiple <a>coordinate reference systems</a>;
the exact CRS needs to be specified to define a location precisely.
<em>TODO: Figure of latitude/longitude</em>
</dd>

<dt><dfn>altitude</dfn></dt>
<dd>
A coordinate that represents the height of a point above or below a reference surface.
A <a>coordinate reference system</a> that uses altitude along with latitude and longitude can define geographic points in 3D space.
Altitude is measured in length units, such as meters or feet.
</dd>

<dt><dfn>feature</dfn></dt>
<dd>
Something of interest on the map.
Conceptually, the map feature includes the location or geographic shape
of this spatial thing, as well as additional information
describing what it is or why it is interesting.
This information may be conveyed on the map with text labels
or with icons, colors, or other cartographic symbols.
</dd>

<dt><dfn data-lt="vector|vector feature">vector feature</dfn></dt>
<dd>
A map feature that has a mathematically defined spatial geometry
based on coordinate data.
Different spatial data structures support different types of vector geometry,
but the basic 2D vector feature types are
<a>point</a>, <a>polyline</a>, and <a>polygon</a>.
<em>TODO: Figure of different types of feature geometries (point, multipoint, polyline, etc.)</em>
</dd>

<dt><dfn>coordinate point</dfn></dt>
<dt><dfn data-lt="point|point feature">point feature</dfn></dt>
<dd>
A spatial location defined by a single set (pair or triple) of coordinates.
A point has no shape or extent,
although in some data formats it may include a level of imprecision or uncertainty.
</dd>

<dt><dfn>polyline</dfn></dt>
<dd>
A vector feature defined as an ordered list of coordinate points,
and the straight lines connecting them.
(Where "straight" is relative to the geometry being described,
and might be across the surface of a sphere.)
</dd>

<dt><dfn>polygon</dfn></dt>
<dd>
A vector feature defined as a two-dimensional shape enclosed by a polyline,
where the last point on the polyline connects back to the first one.
In some data formats, a polygon includes a shape with holes (exclusions) in it,
where the hole is defined by a separate enclosed polyline.
</dd>

<dt><dfn>coverage</dfn></dt>
<dd>
Spatial data that conceptually represents a measurable value that varies across space.
In practice, coverage data is usually encoded as a grid of points
at a specified resolution, with the data value at each point.
This grid of values can often be represented as pixel colors in a <a>raster map layer</a>.
</dd>

<dt><dfn data-lt="layer|map layer">(map) layer</dfn></dt>
<dd>
A subset of the map's graphics which could be rendered independently
from other graphics for the same region.
Multiple map layers can be aligned based on their shared <a>coordinates</a>,
then composited together (drawn one on top of another) to create the final map view.
</dd>

<dt><dfn>base layer</dfn></dt>
<dd>
The map layer that provides the background/bottom layer in the compositing stack.
It is usually fully opaque.
</dd>

<dt><dfn>overlay</dfn></dt>
<dd>
A partially-transparent <a>map layer</a>,
designed to be positioned on top of a <a>base layer</a>.
</dd>

<dt><dfn data-lt="vector map|vector map layer">vector map layer</dfn></dt>
<dd>
A map layer defined using data structures that describe individual <a>vector features</a>
and their coordinates,
which is then used as input instructions to drawing code in the map rendering tool.
Vector formats can preserve the meaning of the different graphical marks on their page,
and allow them to by dynamically styled or altered by the map rendering software.
But, that flexibility requires more processing power in the rendering software,
and may require more data to represent very detailed graphics.
</dd>

<dt><dfn data-lt="raster|raster map|raster layer|raster map layer">raster map layer</dfn></dt>
<dd>
A map layer defined using raster image formats,
which specify the final colors at each position (pixel) in the rendered result.
Raster maps can be generated from vector data,
or they may be created from photographs or drawings.
</dd>

<dt><dfn data-lt="tile|tiled">tile</dfn></dt>
<dd>
A subset of a map layer that represents a particular region of the map,
usually a rectangle in a particular map projection.
Larger regions of the map can be drawn by rendering multiple tiles
side-by-side in a grid.
In a <a>slippy map</a>, tiles can be fetched from a server and rendered as needed
when the user moves the view to different parts of the map.
Tiles can be <a>raster</a> or <a>vector</a>,
although raster tiles are currently more common for web maps.
</dd>

<dt><dfn>tileset</dfn></dt>
<dd>
A set of map tiles which can be used as a map layer.
In simplest tilesets, the map tiles combine as a grid (<dfn>tile matrix</dfn>) to form a single map layer.
More complex tilesets include multiple tile matrices covering the same regions at different scales (zoom levels).
<em>TODO: Create/find figure explaining tileset pyramids.</em>
</dd>

</dl>

</section>

</section>

<section id="principles">
<h2>Guiding Principles</h2>
<p>
The structure of this review is inspired by many other projects
that have outlined best practices for web standards developments.
This section briefly outlines the principles behind our approach,
with links to further reading.
</p>

<section id="extensible-web">
<h3>The extensible web</h3>
<p>
The report uses an evidence-based approach,
defining requirements not based on hypothetical use cases
but on web map tools that are already in use.
We assume that
the common features of existing, widely-used web map frameworks
represent core functionality
that web users and website authors expect from native web maps.
</p>
<p>
This approach is inspired by [[[EXTENSIBLE]]]
which aims to
“tighten the feedback loop between the editors of web standards and web developers,”
establishing “a clear path for good ideas by web developers to become part of the infrastructure of the web”
[[EXTENSIBLE]].
</p>
<p>
Much of the manifesto focuses on making it easier
for developers to experiment with new features —
to expose web platform capabilities at a more granular level,
so that developers can remix and extend them to try out new ideas.
HTML custom elements and CSS custom properties
are just two of many examples of how web standards efforts since 2012
have focused on creating better building blocks for web developers.
</p>
<p>
But the implicit second step of the extensible web approach
is that, once a consensus has developed from real-world experience
with particular features or patterns on the web,
those features can be standardized with confidence.
</p>
<p>
Web maps are extremely complex user interfaces.
If that complexity is to be built-in to web browsers,
the extensible web mindset requires that it be exposed
to developers as individual capabilities that can be remixed and extended.
For that reason,
this review breaks web map functionality
into very low-level capabilities.
In addition to describing how each capability is used in mapping,
we discuss how the same building block could be used for other web content.
Focusing on these low-level capabilities also ensures
that we do not overlook important details,
such as the need to make individual interactions accessible to all users.
</p>
</section>

<section id="priorities">
<h3>Priorities for web standards</h3>

<p>
To decide whether a capability
should or shouldn't be considered a requirement for web maps,
we need to assess its benefits and costs.
But benefits and costs are subjective:
to calculate them, we need a set of values or principles
defining best practices for web standards.
Only then can we assess whether integrating a feature into web browsers
can bring the web closer to our ideals.
</p>
<p>
Benefits and costs are also different from different perspectives.
Integrating web maps into HTML means convincing
other web standard editors and web browser developers.
But once a web standard is adopted,
the number of website authors who use it will (hopefully)
be much larger than the number of people who worked on the initial standard;
the number of people who use those websites will be larger still.
The [[[html-design-principles]]]
rely on these numbers to establish a “priority of constituencies”:
</p>
<blockquote>
In case of conflict, consider users over authors over implementors over specifiers over theoretical purity.
…
Of course, it is preferred to make things better for multiple constituencies at once.
[[html-design-principles]]
</blockquote>
<p>
This section introduces the categories by which we measure
costs and benefits to each of these constituencies.
</p>

<section id="principles-users">
<h4>Users</h4>
<p>
An inclusive web is available to everyone,
to connect and create in the ways most comfortable to them.
</p>
<p>
In this report,
the user-friendliness of a potential web map feature is assessed on these points:
</p>
<dl>
<dt>privacy & security</dt>
<dd>
<p>
Can this feature be implemented in a privacy-respecting manner?
Are there any other security concerns from this feature?
Would making it a built-in feature, standardized in web browsers,
improve privacy & security compared to current web practice?
</p>
<p>
Tags for the costs and benefits of potential requirements:
</p>
<ul>
<li>
<dfn id="privacy-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Privacy: potential improvement</dfn>
indicates that a built-in browser implementation of this feature,
if done correctly,
could improve the protection of the end user's privacy,
compared to current practices on the web.
</li>
<li>
<dfn id="privacy-potential-origin"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Privacy: potential improvement for website origin isolation</dfn>
indicates that a built-in browser implementation of this capability,
if done correctly,
could make it easier for website authors to use web maps
without exposing confidential (user or corporate) data to third parties.
</li>
<li>
<dfn id="security-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Security: potential improvement</dfn>
indicates that a built-in browser implementation of this capability,
if done correctly,
could improve the protection of the security of the browser environment, compared to current practices.
</li>
<li>
<dfn id="privacy-personal-data"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Privacy: involves personal data</dfn>
indicates that in order to fully implement this capability,
the browser would have access to sensitive or personally-identifying data about the user,
which would need to be protected.
</li>
<li>
<dfn id="privacy-fingerprinting"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Privacy: possible fingerprinting</dfn>
indicates that implementing this capability
would expose to website code user settings or data from device sensors,
which could make it easier for website trackers to generate a unique “fingerprint”
for identifying that user across many sites.
</li>
<li>
<dfn id="privacy-sensitive-data-revealed"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Privacy: reveals sensitive data</dfn>
indicates that fully implementing this capability
requires revealing sensitive or personally-identifying data to website code.
</li>
<li>
<dfn id="security-ui"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Security: user interface override</dfn>
indicates that this capability allows website code to alter the normal browser UI
in a way that could be used by a malicious code to mislead users.
</li>
<li>
<dfn id="security-risks"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Security: other risks</dfn>
indicates that this capability includes other aspects
that could make a secure implementation difficult.
</li>
</ul>
<p>
Further information:
</p>
<ul>
<li>
<a href="https://w3ctag.github.io/security-questionnaire/">W3C TAG's Security and Privacy Self-Review Questionnaire</a>
[[security-privacy-questionnaire]]
</li>
<li>
[[[GEOLOCATION-PRIVACY]]] [[GEOLOCATION-PRIVACY]]
</li>
</ul>
</dd>
<dt>accessibility</dt>
<dd>
<p>
Does including this capability in a web map standard
make it easier to ensure an accessible experience
(assuming an accessibility-focused browser implementation)?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="accessibility-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Accessibility: potential improvement</dfn>
indicates that a built-in browser implementation of this feature,
if done correctly,
could improve the accessibility compared to current practices on the web.
</li>
<li>
<dfn id="accessibility-info-needed"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Accessibility: research needed</dfn>
indicates that there is not a clear best practice
for how to implement this capability accessibly.
</li>
<li>
<dfn id="accessibility-author-context"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Accessibility: needs author-provided context</dfn>
indicates that a good browser implementation is not enough
to make this capability fully accessible;
content author would always need to provide extra information
(e.g., alternative text or captions).
</li>
</ul>
<p>Further information:</p>
<ul>
<li>
[[[FAST]]]
and its
<a data-cite="FAST/checklist.html">checklist</a>
[[FAST]]
</li>
<li>
<a href="https://www.w3.org/TR/WCAG/">Web Content Accessibility Guidelines</a>
[[WCAG21]]
</li>
<li>
<a href="https://www.w3.org/WAI/standards-guidelines/atag/">Authoring Tool Accessibility Guidelines</a>
[[ATAG20]]
</li>
<li>
<a href="https://www.w3.org/WAI/standards-guidelines/uaag/">User Agent Accessibility Guidelines</a>
[[UAAG20]]
</li>
<li>
<a href="https://www.w3.org/WAI/RD/wiki/Accessible_Maps">Accessible Maps</a>,
a wiki page compiled by members of the Research and Development Working Group of the W3C Web Accessibility Initiative (WAI) focusing on non-visual map presentations
</li>
<li>
[[[media-accessibility-reqs]]],
particularly the system requirements about interactive controls and navigation
[[media-accessibility-reqs]]
</li>
<li>
<a href="https://www.w3.org/WAI/personalization/">WAI's personalization overview</a>,
and in particular the [[[personalization-semantics-requirements-1.0]]]
[[personalization-semantics-requirements-1.0]]
</li>
</ul>
</dd>
<dt>internationalization & localization</dt>
<dd>
<p>
Can this feature be implemented in a manner that works for all languages and regions?
Does building it into the browser increase the likelihood that internationalization is done correctly?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="i18n-potential-text"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Internationalization: potential improvement (languages)</dfn>
indicates that a native browser implementation,
if done correctly,
could improve the handling of text in many languages,
compared to current practices in web maps.
</li>
<li>
<dfn id="i18n-potential-geo"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Internationalization: potential improvement (spatial data)</dfn>
indicates that a native browser implementation,
if done correctly,
could improve the ability of web maps (compared to current practices)
to work in many regions with different ways of describing locations and other spatial data.
</li>
<li>
<dfn id="i18n-localized-UI"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Internationalization: UI localization required</dfn>
indicates that a correct implementation of this feature
would need to include translations or other localizations (e.g., different icons or layout).
</li>
<li>
<dfn id="i18n-regional-data"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Internationalization: regional standards</dfn>
indicates that the standard UI patterns or data formats vary by geographic region.
</li>
<li>
<dfn id="i18n-difficult"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Internationalization: difficult to do well</dfn>
indicates that the capability involves other aspects
that are frequent sources of internationalization and localization errors.
</li>
<li>
<dfn id="i18n-unstable"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Internationalization: unstable data</dfn>
indicates that a correct implementation depends
on information that may change over time  ,
and would need to be updated by the browser.
</li>
</ul>
<p>
Further information:
</p>
<ul>
<li>
<a href="https://www.w3.org/International/techniques/developing-specs?collapse">W3C Internationalization checklist</a>
</li>
<li>
<a href="https://w3c.github.io/bp-i18n-specdev/">Internationalization Best Practices for Spec Developers</a>
[[international-specs]]
</li>
</ul>
</dd>
<dt>performance & cost to users<dt>
<dd>
<p>
Would building in this feature significantly reduce the amount of data downloaded to the user device,
or the amount of custom code that needs to run?
Or would it impose heavy computation demands on the user device?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="performance-data-savings"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Performance: data savings</dfn>
indicates that making this a browser feature could reduce data demands on the user's network.
Of course, nearly any built-in capability will create some data savings
compared to downloading JavaScript to achieve the same effect;
this tag is only used when the potential data savings are particularly notable.
</li>
<li>
<dfn id="performance-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Performance: potential optimization</dfn>
indicates that a native browser implementation
could be much more efficient in its computation requirements,
compared to JavaScript tools.
</li>
<li>
<dfn id="performance-high-impact"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Performance: high cost feature</dfn>
indicates that this feature involves high performance costs,
regardless of whether it is defined in browser code or in JavaScript.
</li>
</ul>
<p>
Further information:
</p>
<ul>
<li class="issue">
  Need references regarding performance considerations for spec developers.
</li>
</ul>
</dd>
</dl>
</section>

<section id="principles-authors">
<h4>Authors</h4>
<p>
Website authors include developers who write code
and writers, designers, and other creators of web content.
When discussing web maps, website authors also include
geospatial experts who create map data and want to publish it on the web.
</p>
<p>
For an author that cares about their user,
it of course helps if there are native implementations
of author-focused features like accessibility.
But there are other ways a good web standard can make the author's job easier:
</p>
<dl>
<dt>simplicity & flexibility</dt>
<dd>
<p>
For an author, a good web standard
should make it easy to create common web patterns,
while still making it possible to create unique and customized experiences.
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="author-simplicity"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author experience: simple defaults</dfn>
indicates that the capability would greatly simplify authoring common use cases.
</li>
<li>
<dfn id="author-extensibility"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author experience: extensible</dfn>
indicates that the capability provides an important hook
for extending the basic web map experience.
</li>
<li>
<dfn id="author-custom-design"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author experience: customizable design</dfn>
indicates that the capability is needed
to allow authors to customize the appearance of web maps
to better integrate with their site design
(while still using other web map capabilities).
</li>
</ul>
</dd>
<dt>maintainability & cost to authors</dt>
<dd>
<p>
Do current implementations of the feature rely on third-party services
which may change in ways that could break website content?
Do they involve ongoing costs that could be mitigated by a native version of the feature?
</p>
<p>Related tags:</p>
<ul>
<li>
<dfn id="author-independence"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author maintainability: removes dependencies on third-party services</dfn>
indicates that current implementations cannot be fully self-hosted by the website,
creating a third-party dependency that could be removed with a native HTML capability.
</li>
<li>
<dfn id="author-cost-cutting"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author maintainability: cost savings</dfn>
indicates that current web map implementations of the feature have ongoing service costs
which could be mitigated by integrating with native platform versions of the feature.
</li>
</ul>
</dd>
<dt>consistency & coordination with the existing web platform</dt>
<dd>
<p>
Can this feature be defined in a way that integrates well with the rest of the web?
Does it reuse API and markup patterns that authors already know?
Can it be added to websites in a way that degrades gracefully in unsupporting web browsers?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="consistency-match"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Consistency: established patterns</dfn>
indicates that this capability can be modelled
after an existing concept or pattern in the web platform.
</li>
<li>
<dfn id="consistency-progressive"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Consistency: progressive enhancement</dfn>
indicates that this capability could be included in websites as an optional enhancement
of existing functionality.
</li>
<li>
<dfn id="consistency-fallbacks"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Consistency: fallbacks possible</dfn>
indicates that this capability could be designed to support degradation
to a fallback state (with corresponding loss of function or extra costs).
</li>
<li>
<dfn id="consistency-with-what"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Consistency: platform is inconsistent</dfn>
indicates that it will be difficult to make this feature consistent with the web platform,
because existing platform features are inconsistent with each other.
</li>
<li>
<dfn id="consistency-broken"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Consistency: breaks established patterns</dfn>
indicates that the feature would be clearly inconsistent with other aspects of the web platform.
</li>
</ul>
</dd>
</dl>

<p>
Further information for all authoring & API design considerations:
</p>
<ul>
<li>
[[[html-design-principles]]] [[html-design-principles]]
</li>
<li>
<a href="https://whatwg.org/faq">WHATWG FAQ</a>,
<a href="https://github.com/whatwg/html/blob/master/FAQ.md">HTML Standard FAQ</a>,
and <a href="https://whatwg.org/policies">WHATWG Policies</a>
</li>
<li>
<a href="https://w3ctag.github.io/webcomponents-design-guidelines/">Guidelines for creating web platform compatible components</a>
[[webcomponents-design-guidelines]]
</li>
<li>
[[[API-DESIGN-PRINCIPLES]]] [[API-DESIGN-PRINCIPLES]]
</li>
</ul>
</section>

<section id="priciples-implementers">
<h4>Implementers</h4>
<p>
Implementers, for a web standard,
are the people who build and maintain web browsers and other user agent software.
Because much of the work of a web browser is to work as the user's agent,
features that are good for the user when it comes to security or performance
are also good for implementers.
But some implementer benefits aren't directly exposed to the user:
</p>
<dl>
<dt>ease of implementation</dt>
<dd>
<p>
An implementation that already exists is always easier.
Could this feature reuse code that is already available to the browser?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="implementation-incremental"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Implementation: Extends web platform</dfn>
indicates that this capability is an incremental extension of existing web platform features,
and could be designed to reuse a lot of existing code.
</li>
<li>
<dfn id="implementation-native"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Implementation: Exposes native platform</dfn>
indicates that, while this capability is not currently available in the web platform,
it exists in native application frameworks supported by the major operating systems.
A web browser could expose the native feature instead of re-implementing it from scratch.
</li>
</ul>
</dd>
</dl>
</section>

</section>
</section>

<section id="use-cases">
<h2>Use Cases</h2>
<p>
The basic use cases for website authors focus on presenting information.
Different types of map data require different display capabilities.
More advanced geographic application development

End users may wish to use that information
in ways that go beyond what the website author intended;
those use cases are grouped separately.
</p>

<section id="content-author-use-cases">
<h3>Content author use cases</h3>

<section id="use-case-create-map" data-ucr-role="use-case">
<h4>Display an interactive map within a web page</h4>
<p>
Before discussing any extra capabilities,
there must be some way to define a map viewer in a web page,
either from markup or from script.
</p>
<p>
Maps on the web are used to give directions,
to display data,
to tell stories,
and to teach geography,
among many other uses.
Of course, most use cases require additional capabilities
— this is just the foundation!
</p>
<figure>
  <img src="images/examples/create-map_google-maps.jpg" width="450" height="336" alt="Google Maps example: Create a basic map.">
  <figcaption>Google Maps example implementation of "Display an interactive map within a web page".</figcaption>
</figure>
<p>
See <a href="examples/create-map.html" target="examples">examples of creating a basic map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="77">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-declarative-map"></a>
  or <a href="#capability-create-initialise-and-display-a-map"></a></li>
</ul>
</section>

<section id="use-case-single-location" data-ucr-role="use-case">
<h4>Display a map centered on a point location</h4>
<p>
For a website creator, this is the simplest web map use case:
display a map from a location description.
Usually, the map layer is at a zoom level that shows streets and points of interest,
with a pinpoint marker showing the specific location.
</p>
<p>
This type of web map is used
by websites for stores, restaurants, and countless other organizations with physical locations.
It is also used by news media to display the location described in an article.
In social media and blogs,
a single-location map can be used to show where a post was uploaded from,
or where a photograph or video was taken.
</p>
<figure>
  <img src="images/examples/single-location_leafletjs-openstreetmap-tiles.jpg" width="450" height="336" alt="Leaflet.js (with OpenStreetMap tiles) example: Single-location map viewer.">
  <figcaption>Leaflet.js (with OpenStreetMap tiles) example implementation of "Display a map centered on a point location".</figcaption>
</figure>
<p>
See <a href="examples/single-location.html" target="examples">examples of single-location map viewers</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="33">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-default-map"></a>
  or <a href="#capability-custom-map-tiles"></a></li>
<li><a href="#capability-location-latlong"></a>
  or <a href="#capability-location-address"></a></li>

<li><a href="#capability-marker-points"></a>
  or <a href="#capability-add-marker-or-multiple-markers-map"></a></li>
</ul>
</section>

<section id="use-case-static-map" data-ucr-role="use-case">
<h4>Display a region of map data as a static image</h4>
<p>
Although this review mainly focuses on interactive map viewers,
authors sometimes want a map displayed as a static image, without pan/zoom capabilities.
This is common in cases where the accompanying text
refers to specific features in the map,
or when a series of maps will be contrasted.
</p>
<figure>
  <img src="images/examples/static-maps_mapbox-static-images.jpg" width="450" height="336" alt="MapBox Static Images example: Display a static image.">
  <figcaption>MapBox Static Images example implementation of "Display a region of map data as a static image".</figcaption>
</figure>
<p>
See <a href="examples/static-map.html" target="examples">examples of static map displays</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="17">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-no-js"></a></li>
</ul>
</section>

<section id="use-case-multiple-location-markers" data-ucr-role="use-case">
<h4>Display multiple point locations as map markers</h4>
<p>
The most common use case for a web map is to show
one or more locations of a business or organization.
Maps that display pinpoint locations can also be used for data visualization,
demonstrating spatial patterns of particular events or occurrences.
Other examples of point markers on a map include
search results (e.g., restaurants),
traffic information (e.g., locations of construction roadworks),
or the locations where photographs in a gallery were taken.
</p>
<p>
For many use cases,
the website author will want to choose the icon used to mark the location,
with different markers for different types of point features.
</p>
<figure>
  <img src="images/examples/multiple-location-markers_bing-maps-control-api.jpg" width="450" height="336" alt="Bing Maps Control API example: Display multiple point locations as map markers.">
  <figcaption>Bing Maps Control API example implementation of "Display multiple point locations as map markers".</figcaption>
</figure>
<p>
See <a href="examples/multiple-location-markers.html" target="examples">examples of displaying multiple point locations as map markers</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="78">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Everything listed in <a href="#use-case-single-location"></a></li>
<li><a href="#capability-marker-points"></a></li>
</ul>
</section>

<section id="use-case-poly-features" data-ucr-role="use-case">
<h4>Display routes/paths or regions</h4>
<p>
Lines and curves (<a>polyline</a> features) drawn on a map represent
roads, rivers, directions between places,
or the observed path of a moving object.
Shapes (<a>polygon</a> features) are used for political regions (country and municipal boundaries),
building footprint outlines,
and for contour lines which mark the extent of a certain value within continuous data
(e.g., elevation).
Polygons are also used for roads, rivers and so on at higher zoom levels,
where the true shape of the feature can no longer be approximated as a single line.
</p>
<figure>
  <img src="images/examples/poly-features_d3-geographies-apis.jpg" width="450" height="336" alt="D3 Geographies APIs example: Display routes/paths or regions.">
  <figcaption>D3 Geographies APIs example implementation of "Display routes/paths or regions".</figcaption>
</figure>
<p>
See <a href="examples/poly-features.html" target="examples">examples of displaying routes and regions</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="36">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Everything listed in <a href="#use-case-single-location"></a></li>
<li><a href="#capability-vector-features"></a></li>
</ul>
</section>

<section id="use-case-html-annotations" data-ucr-role="use-case">
<h4>Display custom web content describing map features</h4>
<p>
Map features often need additional content attached to them
in order to provide context for the viewer.
For example, with the most common mapping use case of displaying the various locations of an organization,
additional content can display a location's opening hours or street address.
</p>
<p>
This use case is especially important for data visualization;
a map can serve as a visual interface that allows a user to navigate map features
and only show the information that they are interested in.
</p>
<figure>
  <img src="images/examples/html-annotations_tomtom-maps-sdk-vector-maps.jpg" width="450" height="336" alt="TomTom Maps SDK for Web example: Display custom content.">
  <figcaption>TomTom Maps SDK for Web example implementation of "Display custom web content describing map features".</figcaption>
</figure>
<p>
See <a href="examples/html-annotations.html" target="examples">examples of displaying custom HTML annotations</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="37">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Everything listed in <a href="#use-case-single-location"></a></li>
<li><a href="#capability-hyperlinks"></a></li>
</ul>
</section>

<section id="use-case-custom-map" data-ucr-role="use-case">
<h4>Display custom imagery as a map layer</h4>
<p>
Many mapping applications require custom imagery
that goes beyond annotations of an existing map.
</p>
<p>
Unlike map <a>features</a>, which can be defined in geometric terms,
map <a>coverages</a> define continuous variations,
and are usually represented as <a>raster</a> image data.
Many maps of natural features involve coverage data,
such as maps showing terrain, vegetation cover, rainfall, or elevation.
Raster image layers are also used for aerial and satellite photographs,
and for pre-rendering vector feature data, on the server or in a specialized application.
Custom map layers — in contrast to maps from major web map services —
are necessary if displaying confidential business data,
new research data,
maps of proposed developments or historical geography,
maps of non-Earth bodies such as Mars and the Moon,
or any other type of map not included in the major wayfinding street maps.
</p>
<p>
When the custom map layer is of a limited scope,
it can often be represented as a single image file.
Single images are practical for <a href="#use-case-static-map">static map views</a>,
and other cases where a broader spatial context is not as important,
or when the author is trying to make a specific point about a set of data.
Single image layers may also be rendered on the fly from a <a>WMS</a>.
</p>
<p>
To support slippy web maps with extensive pan and zoom capabilities, however,
the custom images need to be divided into tilesets
and the map viewer needs to be able to dynamically fetch the correct images.
</p>
<figure>
  <img src="images/examples/custom-map_mapbox-gl.jpg" width="450" height="336" alt="MapBox GL example: Display custom imagery as a map layer.">
  <figcaption>MapBox GL example implementation of "Display custom imagery as a map layer".</figcaption>
</figure>
<p>
See <a href="examples/custom-map.html" target="examples">examples of specifying a data source for a map tile layer</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="38">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-single-custom-image"></a> or <a href="#capability-custom-map-tiles"></a></li>
<li>For more complex maps, <a href="#capability-lazy-load"></a> and <a href="#capability-zoom-swap"></a></li>
<li>For adding custom maps from script, <a href="#capability-define-data-source-tile-layer"></a></li>
</ul>
</section>

<section id="use-case-layers" data-ucr-role="use-case">
<h4>Combine multiple layers of map tile data or features</h4>
<p>
This is one of the fundamental use cases of web mapping.
Because creating a complete tileset is such a large endeavor,
almost all web maps use a pre-existing set of tiles from a provider,
in combination with any number of layers
consisting of data or features created by the map author.
</p>
<p>
See <a href="examples/layers.html" target="examples">examples of multi-layer maps</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="11">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-single-custom-image"></a> or <a href="#capability-custom-map-tiles"></a></li>
<li>For adding custom maps from script, <a href="#capability-define-data-source-tile-layer"></a></li>
</ul>
</section>

<section id="use-case-alternative-layers" data-ucr-role="use-case">
<h4>Provide alternative map layers which the user can select</h4>
<p>
Different users may be interested in different aspects of a map (e.g., roads vs terrain),
or may prefer different styles (e.g., light vs dark).
When alternative maps are available,
the website author needs a way to display the options to the end user,
and easily swap them on the user's request.
</p>
<p>
Note: the ability to re-style the default map interface is also listed
<a href="#use-case-color-scheme">as a web-visitor use case</a>.
But alternative map layers are part of the content, as well.
</p>
<figure>
  <img src="images/examples/alternative-layers_apple-maps-mapkit-js-api.jpg" width="450" height="336" alt="MapKit JS (Apple Maps) API example: Provide alternative map layers which the user can select.">
  <figcaption>MapKit JS (Apple Maps) API example implementation of "Provide alternative map layers which the user can select".</figcaption>
</figure>
<p>
See <a href="examples/alternative-layers.html" target="examples">examples of allowing the user to select a different style for a map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="81">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>(declarative) or <a href="#capability-specify-style-map"></a> (API)</li>
<li><a href="#capability-determine-current-style-map"></a></li>
</ul>
</section>

<section id="use-case-technical-drawings" data-ucr-role="use-case">
<h4>Display drawings or schematics without geographic coordinates</h4>
<p>
Many of the capabilities of a map viewer widget —
panning and zooming, possibly with synchronized layers
or dynamically loaded content for different positions or zoom layers —
are useful for non-map content,
or for maps that don't have geographic coordinates.
Examples include technical schematics, blueprints,
data charts,
“mind maps” and other flow charts,
or maps of fictional places.
An author who is familiar with map widgets
would want to reuse the same technology
for displaying these types of map-like content.
</p>
<figure>
  <img src="images/examples/technical-drawings_leafletjs-openstreetmap-tiles.jpg" width="450" height="336" alt="Leaflet.js (with OpenStreetMap tiles) example: Non-geographic content in map viewers.">
  <figcaption>Leaflet.js (with OpenStreetMap tiles) example implementation of "Display drawings or schematics without geographic coordinates".</figcaption>
</figure>
<p>
See <a href="examples/technical-drawings.html" target="examples">examples of non-geographic content in map viewers</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="1">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-single-custom-image"></a></li>
<li><a href="#capability-tile-coordinate-systems"></a></li>
</ul>
</section>

<section id="use-case-animated-spatial-data-in-layers" data-ucr-role="use-case">
<h4>Include animated spatial data in a layer</h4>
<p>

</p>
<p class="issue discussion" data-number="182">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-require-interaction" data-ucr-role="use-case">
<h4>Require interaction before allowing pan/zoom (or opt-out of such potentially default behavior)</h4>
<p>
When a user hovers their mouse pointer – even if just briefly – over an in-page map viewer
before wanting to continue scrolling the page (or panning the screen display on touch devices),
map viewers are often panned or zoomed instead,
as a result; the user is trapped from scrolling the web page as intended until moving the cursor (or finger)
outside of the map viewer.
</p>
<figure>
  <img src="images/examples/require-interaction-to-pan-zoom_google-maps.jpg" width="450" height="336" alt="Google Maps example: Require interaction before allowing pan/zoom.">
  <figcaption>Google Maps example implementation of "Require interaction before allowing pan/zoom".</figcaption>
</figure>
<p class="issue discussion" data-number="180">
Discuss this section on GitHub.
</p>
</section>

</section>

<section id="visitor-use-cases">
<h3>Website visitor use cases</h3>

<section id="use-case-interactive" data-ucr-role="use-case">
<h4>Reposition or scale a map to find more context for the displayed locations</h4>
<p>
Users often want more information than is initially visible in a map viewer.
The user may zoom out or pan, to help place the displayed location in a larger context.
Or they may zoom in, to see details more clearly.
</p>
<p>
This use case exists regardless of how the user interacts with their device.
For it to be fully supported, the map viewer must be explorable
with all of the following input methods:
</p>
<ul>
<li>mouse/trackpad pointer (with or without a scroll wheel)</li>
<li>touchscreen gestures</li>
<li>standard/intuitive keyboard shortcuts</li>
<li>accessibility API events (e.g., as triggered by a screen reader or voice control software)</li>
</ul>
<p>
Test out panning and zooming on the <a href="examples/single-location.html" target="examples">basic single-location map views</a>
for the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="39">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-pan-zoom-or-re-centre-map"></a></li>
</ul>
</section>

<section id="use-case-reset-map-view" data-ucr-role="use-case">
<h4>Reset the map to the initial view</h4>
<p>
It is common for a map viewer to be provided in a web page to show an area relevant to the subject of the page.
An encyclopedia might include a map on its page about a battlefield;
a city guide might include a map on its page about the central railway station.
</p>
<p>
When a user interacts with the map,
they may end up viewing a location far from the starting point,
or with the map at a zoom level which is inconvenient for relating the map view
to the primary content of the page.
</p>
<p>
In such a case it would be useful to provide a mechanism
by which the user can reset the map to the original configuration provided
by the web page author.
</p>
<p>
See <a href="examples/reset-map-view.html" target="examples">examples of allowing a user to reset the map to their starting point</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="83">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>As a custom application feature:
  <ul>
  <li><a href="#capability-pan-zoom-or-re-centre-map"></a></li>
  </ul>
</li>
</ul>
</section>

<section id="use-case-rotate-map" data-ucr-role="use-case">
<h4>Rotate a map, or reset the bearing</h4>
<p>
When following directions on a map,
many people find it easier if the map is oriented to the direction they are facing in real life.
But rotating a map (intentionally or accidentally),
can confuse orientation, too,
so it is also useful to have an easy way to reset the map bearing (rotation)
to the standard view:
with the cardinal directions (North-South and East-West)
aligned screen dimensions (top-bottom and left-right).
</p>
<p>
Test out map rotation on the <a href="examples/single-location.html" target="examples">basic single-location map views</a>
for the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="114">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-change-bearing-map"></a></li>
</ul>
</section>

<section id="use-case-identify" data-ucr-role="use-case">
<h4>Access additional information about a point on the map</h4>
<p>
A map view can't show everything all at once.
Users often want to find more information about the representations on the map.
This information could be presented as details displayed on demand
in a pop-up box or sidebar.
</p>
<p>
The details that are available might include the coordinates of the point,
labels for any features at that point,
metadata or links to further information about the features,
or
local data values for continuous coverage data layers.
</p>
<p>
Some of this information might require querying the server with the selected coordinates.
But to the extent that the information is already available in the map viewer,
it should be accessible by users without the author adding extra features.
</p>
<p class="issue discussion" data-number="21">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-hide-layers" data-ucr-role="use-case">
<h4>Show/hide map layers or feature sets</h4>
<p>
A multi-layered map can be overwhelming.
Users sometimes want to remove overlays or features that aren't relevant to them.
In addition, comparisons between two maps (e.g., for before and after effects) can often be seen more clearly
by toggling between two states within the same display.
</p>
<p>
See
<a href="examples/show-and-hide-features-overlays.html" target="examples">examples of allowing a user to show and hide overlays and features</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="115">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Declarative / default behavior:
  <a href=""></a>
</li>
<li>As a custom application feature:
  <ul>
    <li><a href="#capability-add-layer-map"></a></li>
    <li><a href="#capability-control-layers-map"></a></li>
  </ul>
</li>
</ul>
</section>

<section id="use-case-bookmark" data-ucr-role="use-case">
<h4>Bookmark a location</h4>
<p>

</p>
<p class="issue discussion" data-number="41">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
  <li><a href="#capability-export-location"></a></li>
</ul>
</section>

<section id="use-case-search-features" data-ucr-role="use-case">
<h4>Search or sort within a set of geographic features</h4>
<p>

</p>
<p class="issue discussion" data-number="42">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-color-scheme" data-ucr-role="use-case">
<h4>Customize the color scheme (light/dark or high contrast)</h4>
<p>

</p>
<p class="issue discussion" data-number="43">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-view-location-securely" data-ucr-role="use-case">
<h4>View the current location on a map, without disclosing to the website</h4>
<p>

</p>
<p class="issue discussion" data-number="75">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-fullscreen" data-ucr-role="use-case">
<h4>View a map in fullscreen mode</h4>
<p>
To get a better view of a map, and to ease navigation,
a user may want to view the map in <a data-cite="fullscreen">fullscreen</a> mode.
</p>
<p class="issue discussion" data-number="109">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-picture-in-picture" data-ucr-role="use-case">
<h4>View a map as a Picture-In-Picture media object</h4>
<p>
Displaying a map viewer as a <a data-cite="picture-in-picture">Picture-In-Picture</a> (PIP)
media object allows for users to navigate to other applications,
or a different tab in the browser from which the map viewer is embedded,
while still being able to see and interact with the map viewer.
</p>
<figure>
  <img src="images/examples/picture-in-picture_google-maps.jpg" width="450" height="336" alt="Google Maps example: View a map as a Picture-In-Picture media object.">
  <figcaption>Theoretical Google Maps example implementation of "View a map as a Picture-In-Picture media object".</figcaption>
</figure>
<p class="issue discussion" data-number="107">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-augmented-reality" data-ucr-role="use-case">
<h4>View a map in augmented reality</h4>
<p>

</p>
<p class="issue discussion" data-number="135">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-offline-maps" data-ucr-role="use-case">
<h4>Save map content for offline use</h4>
<p>

</p>
<p class="issue discussion" data-number="123">
Discuss this section on GitHub.
</p>
</section>

</section>

<section id="application-use-cases">
<h3>Application developer use cases</h3>
<p>
Built-in mapping widgets cannot cover all possible mapping applications.
Web application developers need to be able extend and manipulate the viewer,
or respond to user interaction with it.
</p>
<p>
Of course, a script-based mapping application will also usually need
scripted control over basic map configuration.
The necessary capabilities are listed above,
under the relevant <a href="#content-author-use-cases">content author use cases</a>.
A web application author may also wish to implement capabilities
for the benefit of the website visitor;
again, the required capabilities are included in the <a href="#visitor-use-cases">visitor use cases</a>.
</p>


<section id="use-case-add-custom-control" data-ucr-role="use-case">
<h4>Add a custom control to a map</h4>
<p>
A control is a user interface component that is integrated
with a map.
It may provide user feedback about the current state of the
map, provide one or more affordances for manipulating the
state of the map, or some combination of the two.
Typically, controls are integrated into the map display in
such a way that no other map content can overlie or obscure
them.
</p>
<p>
Many client APIs allow developers to implement custom
controls and add them to a map.
The advantage of using a custom control is that it becomes a
peer of the native controls provided by the map, and thus
acquires any inherent capabilities and behaviours of those
controls.
For example, if a map provided a way for the user to hide
all controls, the custom control would be hidden along with
the native controls.
This close integration cannot be achieved by a component
which is external to the map, and only made to appear as if
visually integrated through positioning, without additional
work; furthermore, the integration may not be reliable in
the long term if it must be achieved by relying on
undocumented or underspecified behaviour of the map API.
</p>
<p>
A web developer may wish to add one or more custom controls
to a map so as to provide capabilities that are not
available within the standard set of controls provided by
the mapping API, or to make up for perceived deficiencies of
the provided controls.
</p>
<p>
For example, a default zoom control may be inaccessible to
keyboard users, in which case it could be replaced with an
accessible version that utilised a public API to effect
zooming in response to the keyboard.
</p>
<figure>
  <img src="images/examples/add-custom-control_openlayers-openstreetmap-tiles.jpg" width="450" height="336" alt="OpenLayers (with OpenStreetMap tiles) example: Add a custom control to a map.">
  <figcaption>OpenLayers (with OpenStreetMap tiles) example implementation of "Add a custom control to a map".</figcaption>
</figure>
<p>
See <a href="examples/add-custom-control.html" target="examples">examples of adding a custom control to a map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="79">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-implement-a-custom-control"></a></li>
</ul>
</section>

<section id="use-case-view-change-events" data-ucr-role="use-case">
<h4>Provide feedback to a user as they manipulate the map</h4>
<p>
A web developer may wish to respond to changes such as
position and zoom level of a map as it is manipulated by the
user, in order to update user interface components
containing information related to the map.
</p>
<p>
For example, an application displaying a list of places of
interest in a city might update the list to highlight those
places that are within the current extent of the map as the
user pans and zooms, or filter the list to only show those
items.
On a device where the user's current location is known, the
distance to the currently-displayed centre of the map, along
with an indication of the user's bearing relative to that
point, could be shown.
If an application is showing a list of items whose
associated locations are represented on the map by markers,
selecting a marker could highlight the corresponding list
item.
</p>
<p>
See <a href="examples/view-change-events.html" target="examples">examples of providing feedback to a user as they manipulate the map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="80">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-get-bounds-map"></a></li>
<li><a href="#capability-map-events"></a></li>
</ul>
</section>

<section id="use-case-set-view-zoom" data-ucr-role="use-case">
<h4>Move a map to a new position and/or zoom level</h4>
<p>
Complex mapping applications often need to control the displayed map view,
independently of the regular <a href="#use-case-interactive">user-controlled panning and zooming</a>.
The developer's code must be able to move a
map to a new position and/or zoom level.
</p>
<p>
For example, the user may be choosing from a list of
locations of interest, and expect the map to adjust to show
the current point of interest at the centre.
If the items among which the user is choosing are not points
but areas, such as administrative regions, then the map may
need not only to move but also to adjust its zoom level to
one which best fits the area.
</p>
<p>
See <a href="examples/set-view-zoom.html" target="examples">examples of moving a map to a new position and zoom level</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="116">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-pan-zoom-or-re-centre-map"></a></li>
<li><a href="#capability-move-the-map-to-display-a-given-location"></a></li>
<li><a href="#capability-pan-and-zoom-to-bounding-box"></a></li>
</ul>
</section>

<section id="use-case-animate-view-change" data-ucr-role="use-case">
<h4>Animate a map through a sequence of points</h4>
<p>
A web developer implementing the display of a number of
locations arranged sequentially may require the ability to
cause the map to animate through the locations by panning
and zooming.
</p>
<p>
Examples include traversing through the points that make up
a set of directions, or through a set of locations that form
part of a temporal sequence.
</p>
<p>
See <a href="examples/animate-view-change.html" target="examples">examples of animating a map through a sequence of points</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="117">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-animate-the-zooming-of-the-map"></a></li>
<li><a href="#capability-animate-the-re-centering-of-the-map"></a></li>
</ul>
</section>

<section id="use-case-change-bearing-map" data-ucr-role="use-case">
<h4>Change the bearing of a map</h4>
<p>
In addition to <a href="#use-case-rotate-map">user-controlled map rotation</a>,
a developer may need to dynamically update the bearing of a map
— that is, to rotate the map view
so that a direction other than North is at the "top".
</p>
<p>
Examples include responding to the orientation of a device,
traversing a route,
and allowing the user to orient themselves with respect to the map
by manipulating it with respect to local landmarks.
</p>
<p>
See <a href="examples/change-bearing-map.html" target="examples">examples of changing the bearing of a map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="84">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-change-bearing-map"></a></li>
</ul>
</section>

<section id="use-case-set-layer-visibility" data-ucr-role="use-case">
<h4>Control which layers are currently visible & which can be hidden by the user</h4>
<figure>
  <img src="images/examples/set-layer-visibility_leafletjs-openstreetmap-tiles.jpg?v=2" width="450" height="336" alt="Leaflet.js (with OpenStreetMap tiles) example: Control which layers are currently visible & which can be hidden by the user.">
  <figcaption>Leaflet.js (with OpenStreetMap tiles) example implementation of "Control which layers are currently visible & which can be hidden by the user".</figcaption>
</figure>
<p>
See <a href="examples/set-layer-visibility.html" target="examples">examples of allowing the user to control the layer displayed by a map</a>
as implemented by the reference JavaScript tools.
</p>

<p class="issue discussion" data-number="82">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>…</li>
</ul>
</section>

<section id="use-case-generate-vector-features" data-ucr-role="use-case">
<h4>Generate new vector features from data</h4>
<p>
Many forms of geographical data are available in vector
formats, such as shapefiles describing the boundaries of
administrative areas and poly lines representing a route.
A web developer wishing to display such external data
requires an API allowing it to be added as an overlay to the
map view.
</p>
<p>
<a href="#use-case-poly-features">Display routes/paths or regions</a>
covers the use of existing vector data, in standard geographic file formats.
However, a web app developer may want to dynamically generate vector shapes from data.
For example, to implement a feature allowing users to draw new shapes on the map,
the developer needs to convert the selected points into a new polygon feature.
</p>
<p>
See <a href="examples/generate-vector-features.html" target="examples">examples of showing a vector data overlay</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="118">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-add-layer-map"></a></li>
<li><a href="#capability-create-an-overlay-defined-by-vector-data"></a></li>
</ul>
</section>

<section id="use-case-heatmap" data-ucr-role="use-case">
<h4>Generate a heatmap overlay from point intensity data</h4>
<p>
Heatmaps are a common way of showing the variation of some
variable across a geographical area,
as the accumulation of intensity created by many point measurements.
</p>
<p>
From the point of view of the end user,
it is a type of <a>coverage</a> data that is displayed as an overlay on a map.
However, many mapping frameworks have specialized APIs
that can generate heatmap layers directly from the point data,
without needing to pre-process it into a <a>raster layer</a>.
</p>
<p>
See <a href="examples/heatmap.html" target="examples">examples of data heatmaps</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="119">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-control-layers-map"></a></li>
<li><a href="#capability-create-an-overlay-defined-by-heatmap-data"></a></li>
</ul>
</section>

<section id="use-case-drag-and-drop" data-ucr-role="use-case">
<h4>Enable drag & drop for map layers</h4>
<p>

</p>
<p class="issue discussion" data-number="106">
Discuss this section on GitHub.
</p>
</section>

</section>

</section>

<section id="js-examples">
<h2>Reviewed JavaScript Tools</h2>
<p>
Numerous options currently exist for a website author
who wants to include a map viewer in a web page,
with a minimum of custom code.
The examples reviewed in this section are used to identify the common features
(and limitations)
of web map viewers.
</p>
<p>
Many major commercial providers of web map data tiles
provide ready-to-use map viewer widgets for websites to use.
In addition, multiple open source JavaScript libraries
have developed to make it easier for website authors to build on other map data services.
</p>
<p class="issue" data-number="25">
Need data to back up the reference implementations.
</p>
<p>
The reviewed implementations come in three forms:
</p>
<ul>
<li>
Embeds that are included in a web page as an <code>iframe</code>;
configuration options are set through the URL in <code>src</code> attribute.
</li>
<li>
JavaScript frameworks that dynamically generate the widget within the current HTML document;
configuration options are passed in as JS function parameters when initializing the map.
</li>
<li>
HTML custom elements,
with configuration through attributes and child elements.
<p class="issue" data-number="23">
Need to decide on web component examples to use as reference.
</p>
</li>
</ul>
<p>
With these different structures, comparisons are not always exact.
Similar functionality may be generated from very different APIs.
We assess first whether a given capability is present in each implementation,
and second whether there are common patterns in how that capability is exposed.
</p>
<p>
For each capability (potential web map feature) that we review,
we assign one of the following implementation levels
to each of the reference tools:
</p>
<dl>
<dt><dfn>full support</dfn></dt>
<dd>
The capability is implemented in a correct and comprehensive manner.
</dd>
<dt><dfn>supported, with limitations</dfn></dt>
<dd>
The feature is implemented,
but there are notable limitations when assessing the implementation
against our <a href="#priorities">priorities</a>.
</dd>
<dt><dfn>partial support</dfn></dt>
<dd>
Some parts of the feature are implemented.
</dd>
<dt><dfn>no support</dfn></dt>
<dd>
The capability could theoretically exist in the tool, but isn't included.
</dd>
<dt><dfn>not applicable</dfn></dt>
<dd>
The capability doesn't make sense for this tool, because of other aspects of its design.
</dd>
</dl>

<p class="note">
Compiling and serving map data is a complex, expensive enterprise.
Many of the map data and search services
require registered developer accounts, with usage-based pricing.
This review focuses on features that are free-to-use for website creators,
at least for low-traffic websites,
or that use data which is available from many interchangeable sources.
However, because of the complexities of pricing models used by some services,
we don't strictly exclude paid features from our assessment of support.
</p>

<section id="google-maps">
<h3>Google Maps embeds and Google Maps Platform API</h3>
<p>
<!-- Not sure what the convention is for formatting footnotes in this report, but perhaps this would be a good source?  https://trends.builtwith.com/mapping/maps/traffic/Entire-Internet. Google Maps holds a 89% market share.-->
By far the most frequently used map widget on the web,<sup>[citation needed]</sup>
Google Maps established many of the de facto standards in how a web map works.
</p>
<p>
Customized iframe embed URLs can be generated from the maps website
(search/customize the view and then select "share"),
or by constructing the URL query string yourself
(a developer API key and account is required).
</p>
<p>
The Google Maps Platform includes a JavaScript API
for generating map viewers and adding custom features and data layers.
It also includes methods to access more complex search functions, local images, and other data.
Most features require an API key and is billed by usage (page views or API requests).
</p>
<p class="issue discussion" data-number="9">
Discuss this section on GitHub.
</p>
</section>

<section id="openstreetmap">
<h3>OpenStreetMap embeds</h3>
<p>
<a href="https://www.openstreetmap.org/">OpenStreetMap</a> is a project to compile free-to-use wayfinding maps of the entire Earth,
from crowdsourced contributions.
</p>
<p>
The interactive map on the group's website can be used to generate embeddable map widgets.
Various options can also be specified
<a href="https://wiki.openstreetmap.org/wiki/Browsing#Other_URL_tricks">in the URL</a> for the embed source.
</p>
<p>
The image tiles created by the project can also be accessed directly by URL recipes,
and these are used in other map viewer widgets and APIs.
The raw data is also re-processed and used by other map data services.
</p>
<p class="issue discussion" data-number="26">
Discuss this section on GitHub.
</p>
</section>

<section id="bing-maps">
<h3>Bing Maps embeds and Bing Maps Control API</h3>
<p>
<a href="https://www.bing.com/maps#">Bing maps</a> provides embeds that can be generated from their website.
For more complex options, the <a href="https://www.microsoft.com/en-us/maps/v8-control">API</a>
can be used to generate widgets with minimal configuration,
but also provides client-side APIs for manipulating the map,
as well as an interface to Bing's search services.
API tokens are required; free and paid plans are available, with usage caps.
</p>
<p class="issue discussion" data-number="27">
Discuss this section on GitHub.
</p>
</section>

<section id="mapkit-js">
<h3>MapKit JS (Apple Maps) API</h3>
<p>
<a href="https://developer.apple.com/maps/web/">MapKit JS</a> provides
a JS framework for integrating Apple Maps in a website,
with a client-side API for customizing interactions,
and integrations with Apple search services.
</p>
<p>
A developer account is required,
along with a method of generating encrypted API tokens on demand on the webserver.
</p>
<p class="issue discussion" data-number="28">
Discuss this section on GitHub.
</p>
</section>

<section id="mapbox">
<h3>Mapbox GL JS API and Mapbox Studio embeds</h3>
<p>
<a href="https://docs.mapbox.com/">Mapbox</a> provides
map data as a service, as well as frameworks for multiple platforms.
The GL JS framework generates map viewer widgets from client-side JavaScript calls,
using WebGL for the actual rendering.
Alternatively, the Mapbox <a href="https://docs.mapbox.com/api/maps/#request-embeddable-html">Maps API</a>
returns complete HTML slippy maps based on URL configuration,
and so can be used as an iframe source. These maps can be configured through <a href="https://www.mapbox.com/mapbox-studio/">Mapbox Studio</a>, a graphical interface for building and styling maps. Each custom map is then assigned an ID, which can be passed into to the slippy map URL in order to fetch the map.
</p>
<p>
An API key is required, with cost based on usage.
</p>
<p class="issue discussion" data-number="12">
Discuss this section on GitHub.
</p>
</section>

<section id="leaflet-js">
<h3>Leaflet.js API</h3>
<p>
<a href="https://leafletjs.com/">Leaflet</a> is a popular open-source JavaScript framework
for building customized map views.
It doesn't currently have a declarative API,
but widgets similar to map embeds can be generated with a few calls to the library methods.
</p>
<p>
Leaflet isn't associated with any particular map data source.
It can use image tiles from most web map (tile) services.
</p>
<p class="issue discussion" data-number="29">
Discuss this section on GitHub.
</p>
</section>

<section id="openlayers">
<h3>OpenLayers API</h3>
<p>
OpenLayers is one of the most established open-source libraries
for creating dynamic web maps from map data in standard formats.
As with Leaflet, it isn't associated with any particular map service.
A basic slippy map can be created with a few lines of custom JavaScript.
</p>
<p class="issue discussion" data-number="30">
Discuss this section on GitHub.
</p>
</section>

<section id="tomtom">
<h3>TomTom Maps SDK for Web</h3>
<p>
TomTom is a provider of geographic search and routing services
and street map imagery.
They provide software development kits (SDK) for mobile and web use,
although their map tile and image APIs can also be used
with other web map frameworks or <a>GIS</a> viewers.
The viewer used by the web SDK is a customized wrapper around <a href="#leaflet-js">Leaflet</a>.
</p>
<p>
TomTom's street map imagery is available as raster tiles,
custom-generated raster images for specified bounds,
or as vector tiles (using Mapbox's vector tile specification).
The example pages use the vector data source.
</p>
<p>
Access to TomTom's map data and search APIs requires an account and API key;
there is a daily quota of free transactions.
</p>
<p class="issue discussion" data-number="49">
Discuss this section on GitHub.
</p>
</section>

<section id="d3-geo">
<h3>D3 Geographies APIs</h3>
<p>
The data visualization library D3 includes the <a href="https://github.com/d3/d3-geo">d3-geo module</a>
which defines methods for manipulating vector map data
(which the website author must provide).
Unlike the other JS tools being reviewed here,
D3 does not include code for a ready-made map viewer widget,
but it is used for custom client-side mapping applications.
</p>
<p class="issue discussion" data-number="13">
Discuss this section on GitHub.
</p>
</section>
</section>

<section id="map-viewers">
<h2>Map Viewer Widget Capabilities</h2>
<p>
The map viewer widget is the interactive component that displays a map to end users.
The map might be the primary purpose of a website,
or a small embedded element in a larger HTML page.
</p>
<p>
For this section of the review,
we focus only on aspects of the map viewer
that are generated by the map widget framework
based on initial configuration and data by the website developers.
In other words,
these are the features that could be represented by elements and attributes
in a native HTML solution.
The next section, <a href="#client-apis">on client-side APIs</a>,
covers custom JavaScript manipulation and event handling for the map view.
</p>
<p>
We also skip over the technical details of how the map data is encoded,
and assume the browser can convert the map data into images on screen.
The potential requirements in this section describe ways in which map viewers
enhance the normal experience of viewing a static image (e.g., <code>img</code> element)
in a web page.
<a href="#map-formats"></a> explores data structures and file formats.
</p>

<section id="map-viewers-capabilities-rendering">
<h3>Rendering base layers</h3>

<section id="capability-declarative-map" data-ucr-role="capability">
<h4>Embed an interactive map viewer, using HTML markup</h4>
<p>
This is the basic capability that is currently missing from the web:
the ability to use HTML code alone to add a map to a web page.
</p>
<p class="issue discussion" data-number="137">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
There are two types of web map implementations that currently come close:
embeddable iframe maps,
and HTML custom element wrappers to JS mapping libraries.
The limitation of iframes is that all configuration must be contained in the source URL,
instead of being able to use a proper markup API of attributes and child elements.
The limitation of custom elements, currently, is that they require extra polyfill JavaScript
in addition to the mapping library JavaScript.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
     Give details about what is/isn't supported in the dd element,
     starting with a link to one of the implementation levels.
     List full implementations first.
     Group implementations (multiple dt for the same dd) when they have the same support.
  -->
<dt>short-name-embed</dt>
<dt>short-name-api</dt>
<dd><a>full support|supported, with limitations|partial support|no support|not applicable</a>:
TO DO<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
TO DO: include img/picture, video, ...?
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
     Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
     Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
     whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
     See examples.
  -->
<p>
This functionality is the base <a data-ucr-role="conclusion">requirement</a> for a native HTML web map feature.
Being able to define a basic map using markup
would be one of the key benefit of having a built-in feature, compared to existing options.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
     Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
</ul>
</section>

<section id="capability-default-map" data-ucr-role="capability">
<h4>Generate a default map for a given area</h4>
<p>
Often, the website author does not want to specify the map data source or other details about the map;
they just want a generic wayfinding map of the area.
</p>
<p class="issue discussion" data-number="8">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The embeds and commercial APIs all provide default street maps
without the author needing to specify the map source.
In contrast, the more flexible APIs
must be combined with a separate map provider (e.g., OpenStreetMap).
</p>
<dl data-ucr-role="implementation-notes">

<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
this is the basic function for these widgets: give it a location, it will draw the map.
</dd>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd><a>no support</a>:
must be combined with a separate map provider.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
No non-map uses for generating a default street map.
But, there may be interest in displaying default maps as static images
in addition to using them within map widgets.
</p>

<h5>Related web specifications</h5>
<p>
…
</p>

<h5>Conclusion</h5>
<p>
This functionality is a highly valuable <a data-ucr-role="conclusion">enhancement</a>
for native web maps,
especially if it could be built on native platform features
that allow the users to download maps in advance for later use.
However, if user agents cannot integrate with a native operating system feature,
they would need to rely on a third-party service for the map data.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li>
<a data-ucr-role="tag" href="#author-simplicity"></a>
Many map services are either paid or require some form of authentication,
even for simple use cases such as this.
Having this capability be a browser feature
reduces complexity for most use cases.
</li>
<li>
<a data-ucr-role="tag" href="#author-independence"></a>
The vast majority of web maps currently utilize either third-party mapping libraries or third party tiles.
Web maps that self-host both library code and tiles avoid third-party dependencies,
but due to the resources required to self-host tilesets,
only a small percentage of map authors opt for this approach.
</li>
</ul>

</section>

<section id="capability-single-custom-image" data-ucr-role="capability">
<h4>Display an image file as a map layer</h4>
<p>
If a web author already has (or can generate on the server) a map
in a standard image format the browser can render — JPEG, PNG, SVG, etc. —
can the map viewer display it as a map layer?
Or will it need to be converted into a geospatial data format?
</p>
<p>
For most use cases, at least some additional metadata will be required,
to align the image pixels to the geographic coordinates of the map.
</p>
<p class="issue discussion" data-number="138">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The majority of the embed maps do not support custom image layers.
The API tools that do support this feature typically accept a layer source, attribution,
and the coordinate system to be used by the image layers,
which can be mapped to pixel units for more simple use cases.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>
</dd>
<dt>mapbox-embed</dt>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dd>
  <a>no support</a>: most embeds do not support this.
  Adding a custom image layer requires more configuration than supported by these tools.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
This capability is essential in order to provide support for non-map materials.
The ability to display non-georeferenced media like technical drawings,
schematics or archival material within a standardized viewer
has a wide variety of practical use cases.
</p>

<h5>Related web specifications</h5>
<p>
The <a data-cite="SVG2#">SVG</a> <code>image</code> element provides an example
of external image content being rendered into a specified rectangle within a coordinate system.
</p>
<p>
Similarly, the <a data-cite="HTML#the-canvas-element">HTML Canvas2D API</a> has a <code>drawImage()</code> method
for rendering a scaled and positioned copy of an external image within the canvas.
</p>
<h5>Conclusion</h5>
<p>
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
</ul>
</section>

<section id="capability-custom-map-tiles" data-ucr-role="capability">
<h4>Display a map using tile data from an author-specified web map service</h4>
<p>
A single image for an entire map layer is impractical on the web
for large, pan-able maps at good resolution.
For this reason, most web map services provide map data as <a>tilesets</a>.
Beyond any <a href="#capability-default-map">default map layer</a> that the viewer provides,
can it process tilesets as a custom map layer?
If so, in what form?
</p>
<p class="issue discussion" data-number="139">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All API tools support some form of this feature, whether it be in the more popular OpenStreetMap standard (often called XYZ), or the <a>WMTS</a> standard. For most services, tiles can be accessed through a URL with the X, Y and Z parameters defined, where X and Y represent the tile coordinates (not to be confused with latitude and longitude), and Z represents the zoom level. One thing to note is that while Google Maps and the OpenStreetMap standard both count tiles from the upper left corner of the map, the WMTS standard has the Y axis inverted, counting tiles from the bottom left, and some transformation may be needed when using certain tools with certain tilesets.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>
</dd>
<dt>tomtom-sdk</dt>
<dd>
  <a>no support</a>: Although TomTom supports <a>WMS</a> services (where the server can generate a single image file for custom map coordinates),
      it does not support <a>WMTS</a> or other custom tile sources
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dd>
  <a>no support</a>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<p>
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li>
<a data-ucr-role="#author-extensibility"></a>
This capability is necessary for many advanced use cases.
</li>
</ul>

</section>

<section id="capability-no-js" data-ucr-role="capability">
<h4>Display a basic map without JavaScript</h4>
<p>
Users may disable JavaScript for security reasons,
or as part of a strategy to reduce data consumption.
In addition, JavaScript can fail because of network errors
or because of a parsing or runtime error in the code.
</p>
<p>
It is reasonable that web maps have reduced functionality without JavaScript.
But ideally, a basic map with text annotations and links should still work without it.
</p>
<p>
A natively-supported, declarative web map viewer would by definition have this capability.
</p>
<p class="issue discussion" data-number="32">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Our reference implementations are primarily JavaScript tools.
Many do not — by default — provide any features when JS is disabled or fails,
although a website author could build in fallbacks
by including links, images, or iframes in the markup
that are replaced when the script runs.
</p>
<p>
For built-in graceful degradation,
iframe embeds potentially offer the best experience,
but all of the reference tools do not support this by default,
the map author must add this feature themselves.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>google-maps-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>supported, with limitations</a>:
  these tools offer options to serve a static image without JavaScript,
  typically by joining together tiles when the map author passes in a center and zoom level parameter
  into a specific URL format.
  However, this is not the default fallback behavior for the embeds
  when JavaScript is turned off;
  adding a fallback image must be implemented as a custom feature.
</dd>
<dt>openstreetmap-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd><a>no support</a>:</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
To the extent that any capabilities of a map viewer are shared with other content,
having that capability work without JavaScript is a shared benefit.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li>
<a data-ucr-role="tag" href="#author-simplicity"></a>
As no tools include this by default,
supporting this capability would dramatically simplify the process of building progressively enhanced maps.
</li>
<li>
<a data-ucr-role="tag" href="#performance-data-savings"></a>
Supporting fallbacks for devices without JavaScript would allow users on poor connections
or those who intentionally disable JavaScript
to have a decent baseline experience.
</li>
<li>
<a data-ucr-role="tag" href="#consistency-progressive"></a>
This capability is fundamental to building progressively enhanced maps.
</li>
</ul>
</section>

<section id="capability-preferred-language" data-ucr-role="capability">
<h4>Display map content in a users preferred language</h4>
<p>

</p>
<p class="issue discussion" data-number="136">
Discuss this section on GitHub.
</p>
</section>

</section>

<section id="map-viewers-capabilities-vectors">
<h3>Vector features and overlays</h3>

<section id="capability-marker-points" data-ucr-role="capability">
<h4>Show pinpoint locations or custom markers on the map</h4>
<p>
A map marker is a small icon that marks a <a>point feature</a>.
Wayfinding maps often have extensive sets of icon markers
that identify different types of features.
In web maps, the pinpoint marker (a circle narrowing into a point at the bottom)
has become standard for identifying any location of interest.
</p>
<p class="issue discussion" data-number="140">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Almost all of the reference tools support map markers in some way.
While most embed tools include some kind of geocoder in order to
support address lookup, the tools typically utilize latitude and
longitude coordinates under the hood, and map authors can pass in
the coordinates to the URL or configuration object upon initialization.
</p>

<p>
The notable standout here is the Google Maps Embed.
Searching for a location by address  will return information
for a 'Place', each with its own ID and information such as
business hours, reviews, and etc. The ID, rather than latitude and longitude,
is passed into the iframe URL in order to bring up the additional
location information for that particular place.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: allows multiple user-specified pinpoint locations to be placed
</dd>
<dt>openstreetmap-embed</dt>
<dd><a>supported, with limitations</a>: only allows you to show a single marker on embedded maps
<dt>bing-maps-embed</dt>
<dd><a>no support</a>: allows for display of a general area but no map markers</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
If the map element were to support non-georeferenced images,
custom markers could be used as an annotation tool for
technical drawings and other similar media.
</p>

<h5>Related web specifications</h5>
<p>
<a data-cite="SVG2#">SVG</a> contains a number of elements that are positioned on a coordinate system.
The coordinates and dimensions of the element are defined in markup,
as attributes on the element.
</p>
<p>
The <a data-cite="HTML#the-canvas-element">HTML Canvas2D API</a> also offers the ability to draw points on a coordinate system,
but images are drawn by passing coordinates into a JavaScript method,
instead of an element such as in SVG.
This method of drawing features is more similar to existing mapping libraries,
which are also reliant on JavaScript.
However, the Canvas API offers a very low level of abstraction in comparison to mapping libraries.
Depending on the complexity of the marker,
the code to draw it may be very verbose.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-vector-features" data-ucr-role="capability">
<h4>Draw polygons or polylines as stylable, interactive vector graphics (separate from the image tiles)</h4>
<p>
Polygons and polylines are two of the most common types of map data features.
</p>
<p>
It is common on the web for vector map data to be pre-rendered
into raster image layers on the server.
However, if the vector feature is important for the web view,
drawing it as separate graphic object means it can be dynamically styled,
associated with labels or descriptions,
and the target of user events.
</p>
<p class="issue discussion" data-number="141">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The tools that support this capability primarily fall under the
API category. All of the API tools support the drawing of lines
and polygons by passing in coordinates into a JavaScript function.
Mapbox differs from the other implementations as it only accepts
files in the GeoJSON format. The embed tools lack support for this capability.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: polygons and polylines can be added and have styling applied to them.
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dd><a>no support</a>:</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<a data-cite="SVG2#">SVG</a> contains both a <code>polyline</code> and a <code>polygon</code> element.
A comma separated list of coordinates is assigned to the <code>points</code> attribute to generate the shape.
</p>
<p>
The way that polylines and polygons are created in the <a data-cite="HTML#the-canvas-element">HTML Canvas2D API</a> is much more manual,
requiring a sequence of calls to the <code>moveTo</code> and <code>lineTo</code> methods.
Like other aspects of the Canvas API,
this syntax can be quite verbose.
</p>
<p>
TODO: Mention HTML <code>area</code> and CSS  <code>polygon()</code> function.
</p>
<p>
TODO: describe how polyline/polygon are represented in the important geospatial specs.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
     Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
     whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
     See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
     Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-hyperlinks" data-ucr-role="capability">
<h4>Support hyperlinks from markers or vector features</h4>
<p>
For a map to be truly a part of the web,
it needs to be able to link to other web resources.
</p>
<p class="issue discussion" data-number="142">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The API tools all provide ways to bind event handlers to map features,
allow map authors to display additional information when a map feature
is clicked. While it is technically possible to to turn map features
into an external link by using JavaScript, this is not a very common
pattern as it may interfere with other user interactions such as panning
and it can produce markup that is not consistent with the functionality of the map.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: map markers and vector features can have popups
  that contain custom HTML, allowing the map author to display hyperlinks within the popups.
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dd><a>no support</a>:</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
This functionality can be used to provide hyperlink support for diagrams.
Any case where an image map may have been appropriate can also benefit from this capability.
</p>

<h5>Related web specifications</h5>
<p>
<a data-cite="HTML#image-maps">HTML Image Maps</a> consist of a large graphic with various subregions,
which serve as links.
A subregion is defined by passing a shape, coordinates, a link target and alt text to an <code>area</code> element.
A significant limitation of image maps is that the coordinates of the area elements
are always defined in pixels and do not automatically scale to match changes in scale of the image
(see <a href="https://github.com/whatwg/html/issues/389">issue discussion on the HTML spec</a>),
and this limits its usage in modern web development.
</p>
<p>
The <a data-cite="SVG2/linking.html#Links">SVG2 specification</a> supports <code>href</code> attributes on <code>a</code> elements within SVGs,
previously, the SVG 1.1 specification required <code>href</code> attributes to be specified within the XLink namespace.
</p>
<p>
Though it is not visible,
<a data-cite="HTML#the-canvas-element">Canvas elements</a> can include keyboard focusable links as a part of a navigable sub DOM.
In order to make links within the canvas work on click, JavaScript is still neccessary.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-attribution" data-ucr-role="capability">
<h4>Display map data attribution and links</h4>
<p>
Map data is subject to copyright,
and use of the maps on the web usually requires at least attribution,
and maybe links to terms of use.
Many map services also include links for end users to report errors.
</p>
<p class="issue discussion" data-number="143">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Standard practice in the reviewed web map tools
is to display this attribution in the lower right of the map widget.
For map viewers that provide their own map data,
the links and copyright is automatically generated.
For map frameworks that allow the developer to specify the map data source,
these "attribution control" values can be set in configuration.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dd><a>supported, with limitations</a>: attribution is automatically generated,
but it is not keyboard accessible.</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
</p>

<h5>Related web specifications</h5>
<p>
Website authors can use <a data-cite="Microdata">Microdata</a> and other related formats to provide attribution data in a standardized format.
How and whether or not this content is displayed is up to the website author,
but the goal is to provide a machine-readable format for important document content.
</p>
<p>
The <a data-cite="HTML#the-cite-element">cite element</a> is for describing references to a cited creative work.
The HTML <code>blockquote</code> and <code>q</code> elements have a <code>cite</code> attribute
where you can pass a URL as the source of a quote,
but browsers currently do not display this information to the end user.
</p>
</section>

</section>

<section id="map-viewers-capabilities-locations">
<h3>Interpreting locations & map positions</h3>

<section id="capability-location-latlong" data-ucr-role="capability">
<h4>Select map view from latitude and longitude point</h4>
<p>
Latitude and longitude defines a point on the Earth's surface,
without requiring any further information.
For website content, latitude and longitude data
might come from photo or video metadata (from GPS-enabled cameras),
or it might be calculated by the author using map search services.
In a dynamic web app, latitude and longitude might be generated
from geolocation on the user's device.
</p>
<p class="issue discussion" data-number="144">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All the reference tools allow the website author
to display a specific location, defined by latitude and longitude,
from a map tile set.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>leaflet-api</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
setting a location by latitude and longitude is straightforward.
</dd>
<dt>open-layers-api</dt>
<dd><a>supported, with limitations</a>:
A location defined with longitude and latitude
<a href="https://openlayers.org/en/latest/doc/faq.html#why-is-my-map-centered-on-the-gulf-of-guinea-or-africa-the-ocean-null-island-">must be converted to the map tile coordinate system</a>,
but the API provides the conversion function.
</dd>
<dt>bing-maps-embed</dt>
<dd><a>partial support</a>: does not support markers for a single location, but it is possible to display a map centered around a particular latitude and longitude point with no marker</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Related web specifications</h5>
<p>
The <a data-cite="geolocation-API">Geolocation API</a>
and <a data-cite="geolocation-sensor">Geolocation Sensor API</a>
expose the user's location using latitude and longitude data.
It should be possible to set the view on a web map using data returned from these APIs.
Both of these APIs use the [[[WGS84]]] as the technical definition
of longitude and latitude (consistent with most modern geospatial standards),
and a web map standard should use the same definition.
[[geolocation-API]][[geolocation-sensor]][[WGS84]]
</p>

<h5>Conclusion</h5>
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-location-address" data-ucr-role="capability">
<h4>Select map view from street address or place name</h4>
<p>
For many mapping use cases,
a website author won't have exact latitude and longitude values pre-calculated.
They'll have street addresses or place names
in a human-readable, localized format.
To convert these addresses or names into a point on a web map,
the web mapping service needs access to a Gazetteer search and corresponding databases.
</p>
<p class="issue discussion" data-number="145">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The majority of reference tools support this functionality, either
through first party support or through popular plugins. This frequently
takes the form of a search form that returns a possible list of
options that the map author can select from. The Google Maps geocoder
is the gold standard amongst these implementations, as it
is more forgiving in terms of search format and provides better
support for different localizations than other alternatives.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: by default, these tools provide address search when setting up the map
</dd>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd><a>supported, with limitations</a>: the default libraries do not support this but there are a wide variety of geocoding plugins that support this capability.</dd>
<dt>bing-maps-embed</dt>
<dd><a>partial support</a>: does not support markers for a single location, but it is possible to display a map centered around a particular street address with no marker</dd>
</dl>


<h5>Uses beyond mapping</h5>
<p>
There are many cases where a website may expect an address from a user.
An input type specifically for addresses has a wide variety applications other than displaying a map,
such as reducing user error when facilitating e-commerce and delivery services.
</p>

<h5>Related web specifications</h5>
<p>
Both the <a data-cite="HTML#attr-fe-autocomplete"><code>autocomplete</code></a> attribute on HTML form controls
and the <a data-cite="payment-request#paymentaddress-interface">Payment Request Payment Address Interface</a>
represent existing attempts to standardize what an address is.
It is noteable that between these two implementations,
there are differences in the way that various fields are named,
and further research would be needed to determine the best path forward.
</p>
<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<li>
<a data-ucr-role="tag" href="#i18n-difficult"></a>
There are significant regional differences when it comes to how addresses are formatted.
A good implementation of this would need to take these regional variations into account.
</li>
<li>
<a data-ucr-role="tag" href="#privacy-personal-data"></a>
It is unlikely that this capability could be supported in a fully client-side way,
the inputted address may be revealed to the browser or website author.
</li>
</ul>
</section>

<section id="capability-tile-coordinate-systems" data-ucr-role="capability">
<h4>Display map tiles defined in various common coordinate systems</h4>
<p>
Most tiled image maps on the web use the Web Mercator
system of dividing map data into image tiles.
As the name suggests, this is based on the Mercator map projection,
with the addition of standard for dividing the map into tiles at different zoom levels.
</p>
<p>
Web Mercator is not appropriate for maps of polar regions,
where the Mercator projection distorts geography.
Other tileset coordinate systems have been defined specifically for polar maps.
In addition, many regions have well-established local map grid coordinate systems,
and being able to use the local grid means access to established map data sources.
</p>
<p>
The technological complexity of supporting different projections
depends on how many other capabilities are supported.
Tiling images doesn't require knowing how those images map to geographic coordinates.
But the tile boundaries and coordinate projection are needed
in order to draw marker points or vector features over the map.
And information about the tileset zoom levels is required
in order to dynamically load content on pan and zoom.
</p>
<p>
Combining map layers with different projections,
or otherwise converting one map projection to another view,
is a separate capability, discussed in <a href="#capability-reproject-maps"></a>.
</p>
<p class="issue discussion" data-number="14">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
With the Google Maps API, you are able to create custom rectilinear projections,
by passing in a bi-directional mapping between coordinate systems.
Leaflet.js supports the Equirectangular,
Elliptical Mercator and Web Mercator projections by default,
and you can use the external plugin
<a href="http://kartena.github.io/Proj4Leaflet/">Proj4Leaflet</a> to
support other projections.
OpenLayers also relies on <a href="https://github.com/proj4js/proj4js">Proj4</a>
in order to support other projections.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd>
  <a>supported, with limitations</a>: (as described above)
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>no support</a>: these embeds only support the Web Mercator projection.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
Support for this capability would allow for non-georeferenced maps to be displayed,
such as maps of non-earth planets and fictional spaces.
</p>
<p>
This capability would also provide support for the visualizing anything that exists in a Euclidean coordinate system,
such as charts that follow a cartesian coordinate system or spherical coordinate systems,
including diagrams for a variety of engineering, scientific and medical purposes.
</p>

<h5>Related web specifications</h5>
<p>
The <a data-cite="geolocation-API#coordinates_interface">Geolocation API</a> already provides a standard interface
for latitude and longitude coordinates under the WGS94 system,
but currently no other reference systems are supported.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-reproject-maps" data-ucr-role="capability">
<h4>Reproject map tile data into a new projection or globe view</h4>
<p>
Map image tiles are usually defined in Web Mercator
or other grid-based tile systems.
For large scale maps (of the globe or continents),
these reveal distortions created by the underlying projections.
Many different map projections exist to more fairly display the relative size and shapes of continents on a flat map.
In addition, within an interactive web environment,
it is possible to use projections which more directly represent the 3D globe
without trying to display it all at once,
letting user interaction rotate it to show parts of interest.
</p>
<p class="issue discussion" data-number="3">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
None of the reference tools support this feature.
<a href="#capability-tile-coordinate-systems">For the
tools that support alternative projections</a>, it is
possible to to work around this by reinitializing the map
in a different projection.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>no support</a>:
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
The number of related specifications that deal with spatial transformation in some way
suggest that there is a desire for the ability to utilize things like general mesh transformations.
Adding support for reprojection in a map capacity
may have the added benefit of providing a foundation for general graphical and text transformation.
</p>

<h5>Related web specifications</h5>
<p>
There are many existing web specifications which support the transformation of graphics to some extent.
The best example is the <a data-cite="filter-effects#feDisplacementMapElement">feDisplacementMapElement</a> filter.
Originally designed for SVG, it can be used to spatially displace an image on the fly.
Also from SVG is the <a data-cite="SVG2/text.html#TextPathElement">TextPathElement</a>,
where text can be rendered along an arbitrary, author-specified path.
</p>
<p>
The <a data-cite="css-transforms-1">CSS transforms</a> specification offers a simple way to transform elements,
ranging from simple 2D transforms such as 'skew' to composite transformations in a 3D space.
</p>
<p>
In terms of 3D examples,
<a data-cite="webGL">WebGL</a> is an example of a web specification where projecting a flat image or 3D texture onto a curved or spherical surface is possible.
WebGL is already used in some cases for interactive reprojection for non-map use cases.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-export-location" data-ucr-role="capability">
<h4>Save the location or export to other application</h4>
<p>
For the user, it is often useful to bookmark or save a location from a map,
separate from the website which included it.
The user may want to export the location to a GPS or native mapping application
so they can calculate directions to it.
</p>
<p class="issue discussion" data-number="146">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Most of the reference tools do not support this capability. Of the tested tools,
only OpenStreetMap offers the option to export a map location in a standard format.
</p>
<dl data-ucr-role="implementation-notes">
<dt>openstreetmap-embed</dt>
<dd><a>full support</a>:
  in addition to being able to generate and share a link or a map embed,
  it is possible to export the point locations as a geo URI.
</dd>
<dt>google-maps-embed</dt>
<dd><a>supported, with limitations</a>:
  a user is able to generate a link to the map that can be shared via a variety of methods,
  but there is no way to easily send this information to another application.
</dd>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>no support</a>:</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
The <a data-cite="web-share">Web Share API</a> is a specification that is designed for sharing links and other content to a destination of the user's choice.
The API was designed to be extended to allow for sharing new types of data
via adding new members to the <code>ShareData</code> dictionary.
</p>
<p>
Though not exclusively a web specification, the Geo URI scheme represents a standard way to represent locations within a given coordinate reference system.
However, it is important to note that Geo URI is considered to be a location estimate, not an exact location.
</p>
<p>
The <a href="https://wicg.github.io/scroll-to-text-fragment/">WICG Text Fragment specification</a> is an example that builds upon the existing use of URL fragments
in order to allow direct linking to a specific portion of text within a page.
In order to not conflict with the existing URL fragment,
this specification introduces a fragment directive delimiter string (":~:")
to indicate that the fragment is a text fragment.
</p>
</section>

</section>

<section id="map-viewers-capabilities-user-navigation">
<h3>User navigation (pan & zoom)</h3>

<section id="capability-zoom" data-ucr-role="capability">
<h4>Zoom the map independently from the rest of the page</h4>
<p>
In addition to panning the view,
it is standard to allow the user to adjust the map scale:
zooming in to increase magnification (show finer detail),
zooming out to decrease magnification (show a wider area).
</p>
<p class="issue discussion" data-number="147">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>The following UI is standard across the reviewed map widgets:
</p>
<ul>
<li>Accessible buttons labelled with plus (+) and minus (-) signs zoom by steps.
</li>
<li>Mouse wheel movements (usually used to scroll the page) are captured
and converted into continuous zoom adjustments
(mouse scroll down becomes zoom out, mouse scroll up becomes zoom in).
Apple Mapkit JS inverts this popular convention.
Modifier keys (such as Ctrl for Google Maps and Shift for Apple Mapkit JS)
may be required so as not to intefere with default scroll behavior.
</li>
<li>Touch gestures for pinch zoom are used to zoom the map instead of the page.
</li>
</ul>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
      Give details about what is/isn't supported in the dd element,
      starting with a link to one of the implementation levels.
      List full implementations first.
      Group implementations (multiple dt for the same dd) when they have the same support.
  -->
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
(as described above)
<dt>mapbox-embed</dt>
<dd><a>supported, with limitations</a>: all of the above is supported, but the buttons do not have any focus styles</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
Localized zooming is used on the web for
charts and diagrams,
photographs (e.g., to examine details in a product photo, or for photo editing apps),
embedded documents (e.g., a PDF viewer),
and sometimes data tables.
</p>

<h5>Related web specifications</h5>
<p>
Zooms are often implemented using <a data-cite="css-transforms-1#">transforms</a>,
which defines the scale as a multiplicative factor compared to the normal size
(<code>scale(2)</code> for doubling the size, zooming in; <code>scale(0.5)</code> to zoom out by the same amount).
Scale transforms are paired with translations to create zoom and pan effects.
[[css-transforms-1]]
</p>
<p>
An alternative approach for describing zoom and pan
is used in <a data-cite="SVG2#">SVG</a> <code>viewBox</code> attribute
and in <a data-cite="media-frags#naming-space">spatial media fragments</a>.
In this system, the container element defines its own width and height (e.g., with CSS)
plus a target rectangle in the zoomable graphic's coordinate system
(x and y offset, plus width and height);
the user agent then zooms and pans the graphic
to display the target rectangle in the available space.
[[SVG2]][[media-frags]]
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps,
with other uses in the web platform.
A zoom specification will need to carefully consider all uses so it can be implemented consistently,
and should be coordinated with panning.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies --><i>To Do</i>
</li>
</ul>
</section>

<section id="capability-pan" data-ucr-role="capability">
<h4>Pan the map display</h4>
<p>
A key part of the interactivity of a web map widget is that the user can change the region displayed.
To pan the map is to shift the view horizontally or vertically,
so a different location is centered in the map display.
</p>
<p>
For mapping, panning is tightly linked with zooming and with dynamic loading of new content.
For this discussion, we've divided them into separate features
so that the costs, benefits, and non-mapping use cases can be assessed separately.
</p>
<p class="issue discussion" data-number="148">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>The following UI is standard among the reviewed map viewers:</p>
<ul>
<li>Drag the map view by clicking and holding a mouse.</li>
<li>Swipe the map view with touch gestures.</li>
</ul>
<p>The following UI is available in some viewers, but not all:</p>
<ul>
<li>Pan the map view with arrow keys.</li>
</ul>
<p>
Many of the maps lack a visible indication of keyboard focus for panning, and do not provide any other affordances
to indicate how keyboard panning should work.
</p>
<dl data-ucr-role="implementation-notes">
<dt>open-layers-api</dt>
<dt>bing-maps-api</dt>
<dd><a>full support</a>: for OpenLayers, a tabindex value must be added to the map container, but keyboard panning events are included natively</dd>
<dt>openstreetmap-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>tomtom-sdk</dt>
<dd><a>supported, with limitations</a>:
  Mouse, touch, and keyboard panning are supported; no keyboard focus indication
</dd>
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>partial support</a>:
  Mouse and touch panning only. Keyboard panning is possible on the google maps web application. Keyboard panning is
  activated when a specific region of the map is focused.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
The standard panning interactions are also common on the web
for other JS-enhanced zoom and pan graphics
(e.g., a close up of a product photograph, a data chart).
Similar interactions may be used in some games,
or in navigation of large spreadsheets.
Creating a native way to trigger panning within a web layout
could help ensure consistent, accessible user experiences for panning.
</p>

<h5>Related web specifications</h5>
<p>
From a rendering perspective,
panning a map is very similar to scrolling a section of a CSS layout.
Important differences:
</p>
<ul>
<li>Although 2D scrolling is supported,
  the interaction usually emphasizes a primary reading axis.
  Panning is usually 2D, and may be conceptually diagonal as often as horizontal or vertical.
</li>
<li>The initial scroller view is usually at the start of the content (and “start” has meaning);
  an initially panning view is often in the middle, with panning in all directions possible.
</li>
<li>Scrollable content is often visually indicated by scrollbars
  (although it is now common to hide scrollbars until use).
</li>
<li>The user interactions are different for some input methods:
  mouse panning uses click and drag instead of mouse wheel for (primary-direction) scroll,
  keyboard panning only uses the arrows, not the space bar and page up/down keys (which trigger scroll in the
  primary axis).
</li>
</ul>
<p>
Panning interactions also overlap with the proposed
<a href="https://www.w3.org/TR/css-nav-1/">CSS spatial navigation</a> spec.
[[css-nav-1]]
</p>
<p>
In web maps and many other applications,
panning effects are combined with <a href="#capability-zoom">zoom effects</a>;
for that reason, panning is often implemented using
CSS transforms or SVG <code>viewBox</code>,
which can also handle zoom.
[[css-transforms-1]][[SVG2]]
</p>

<h5>Conclusion</h5>
<p>
Panning the map is universally supported in JS web maps,
and is therefore a <a data-ucr-role="conclusion">requirement</a> for native web maps.
The relevant specification should be coordinated with CSS,
considering other use cases for panning on the web.
Thought is needed on how to make panning accessible to all users.
</p>
<ul>
<li><a data-ucr-role="tag">accessibility-info-needed</a>
  There are no established patterns for indicating that panning is possible.
</li>
<li><a data-ucr-role="tag">accessibility-potential</a>
  Keyboard accessibility is implemented poorly on the web;
  accessible browser implementations would be an improvement.
</li>
<li><a data-ucr-role="tag">implementation-incremental</a>
  Panning builds upon established, highly optimized scrolling mechanisms.
</li>
</ul>
</section>

<section id="capability-lazy-load" data-ucr-role="capability">
<h4>Load additional map tiles when they pan into view</h4>
<p>
For web maps using a tileset,
an initial series of tiles is loaded based on the current position of the map.
Tiles are lazily loaded,
and as such additional ones are loaded when they are panned into view.
This allows for a smaller initial payload and improved performance.
</p>
<p>
This capability is closely tied to the previous capability,
<a href="#capability-pan">panning the map display</a>.
</p>
<p class="issue discussion" data-number="149">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All of the reference tools support this capability as described.
Most tools show gray placeholder tiles while the additional tiles are being loaded,
but Google Maps shows a placeholder that is representative of the tile to be loaded
(ie. a blue tile for ocean tiles).
Bing maps takes a similar approach and shows a very low resolution tile,
until new tiles are fetched.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
</dd>
</dl>

<h5>Uses beyond mapping</h5>
<p>
Dynamic loading of additional data is a common feature request for SVG charts and diagrams.
Because the initial performance impact of loading and rendering large amounts of data can be quite significant,
native web features that deal with the management of data
have potentially wide-reaching performance benefits.
</p>

<h5>Related web specifications</h5>
<p>
<a data-cite="HTML/urls-and-fetching.html#lazy-loading-attribute">Image lazy loading</a> is an example of a feature in the native web platform
that benefits performance.
This attribute is extremely simple for developers to implement
and offloads the complexity of deciding when to load the image
onto the browser.
</p>
</section>

<section id="capability-wrap-pan" data-ucr-role="capability">
<h4>Wrap/duplicate data tiles when panning around the globe</h4>
<p>
A web map is not subject to the same limitations of printed maps
and can be panned infinitely along an axis.
Tiles should be wrapped along at least one axis
in order to create a seamless panning experience.
</p>
<p class="issue discussion" data-number="150">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All of the reference tools support this capability.
Google Maps and Bing Maps cache the tiles once they are loaded,
but Leaflet, Open Street Map and the Open Layers API
re-fetch the same tiles as the user pans across the map.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as describe above)
</dd>
</dl>

<h5>Uses beyond mapping</h5>
<p>
Some UI patterns commonly found on the web,
such as carousels and marquees,
utilize a similar kind of wrapping logic.
Since the marquee element was declared obsolete,
there is no way to incorporate wrapping/looping functionality natively,
so incorporating this feature into web maps may have other potential benefits.
</p>
</section>

<section id="capability-scale-adjust" data-ucr-role="capability">
<h4>Maintain reasonable scale of labels and lines when zooming</h4>
<p>
Zooming a map widget is different from
magnifying a regular image, or adjusting the overall browser zoom level;
the layout is magnified, but annotations such as text size and stroke width are not.
</p>
<p>
It should be noted that the Web Content Accessibility Guidelines <a href="https://www.w3.org/WAI/WCAG21/Understanding/resize-text.html">Success Criterion 1.4.4</a>
requires that all text be zoomable indepedent of the content by up to 200%.
</p>
<p class="issue discussion" data-number="151">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>All of these tools scale their labels to match the zoom level,
but labels of smaller map features can be very small
and may not reflect the users text size preference.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
</dl>

<h5>Related web specifications</h5>
<p>
The SVG2 <a href="https://svgwg.org/svg2-draft/coords.html#VectorEffects"><code>vector-effects</code> property</a>
contains a <code>non-scaling-stroke</code> property
that allows for an object's stroke to be unaffected by transforms and zoom.
This can be used for data visualization,
such as graphs or diagrams
where an author may want to display a line with a consistent width across a responsive SVG
that still respects the browser zoom level,
which may otherwise appear too small on mobile screens
and too big on larger screens.
</p>
</section>

<section id="capability-zoom-swap" data-ucr-role="capability">
<h4>Dynamically load different resolution map tile on zoom</h4>
<p>
A limited set of tiles is loaded initially
in order to send the user the smallest amount of data required to render the map.
When the zoom level is changed, additional tiles should be loaded and rendered seamlessly.
</p>
<p>
This capability is related to <a href="#capability-zoom">zoom the map display</a>.
</p>
<p class="issue discussion" data-number="152">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All reference tools support this capability as described.
Google Maps differs from the other reference tools
in that it uses colored placeholder tiles
in order to provide an indication of the tile type before it has loaded.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
</dl>

<h5>Uses beyond mapping</h5>
<p>
Diagram and chart authors on the web often find themselves in a situation
where showing different resolutions would be beneficial for performance.
</p>

<h5>Related web specifications</h5>
<p>
The <a data-cite="HTML/embedded-content.html#element-attrdef-img-srcset">HTML Picture element</a>
is an example of a native way for authors to specify different versions of an image for display at different sizes.
The author can pass as many <code>source</code> elements as needed as child elements of the <code>picture</code> element,
and each source has a media attribute that accepts a media query for what environments the referenced file should be used in.
For simpler cases (the same image rendered at different resolutions),
the <code>srcset</code> and <code>sizes</code> attributes on an HTML <code>&lt;img&gt;</code> element
can be used to similar effect.
While either syntax may be too verbose for use with map tiles
(they require full URLs for every image, at multiple zoom levels, to be specified in the code,
and would require the same number of tiles regardless of zoom level)
it does serve as an example of this functionality being provided in the HTML specification.
</p>
</section>

<section id="capability-zoom-swap-vectors" data-ucr-role="capability">
<h4>Hide or show (and maybe dynamically load) vector features and labels on zoom</h4>
<p>
By default, web maps allow for the user to control the zoom level.
Certain vector features may not be perceivable at higher zoom levels,
and thus they should be hidden at higher zoom levels.
</p>
<p class="issue discussion" data-number="153">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>Support for this capability depends on the tileset,
but all of the reference tools implement this capability
with their default tilesets.</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
</dl>

<h5>Uses beyond mapping</h5>
<p>
This is another capability that could have applications in SVG and other drawing-based web specifications.
Chart and diagram authors may want to have control over the level of detail displayed at different zoom levels and canvas sizes.
</p>

<h5>Related web specifications</h5>
<p>
In SVG, authors most frequently accomplish this by using <a data-cite="mediaqueries-4">Media Queries</a>
to hide and show elements based on the window size,
but this approach is limited to cases where the graphic fills the full document window
(or <code>&lt;iframe&gt;</code>).
<a data-cite="css-contain-1">CSS Containment</a> may potentially provide a more elegant solution
for allowing authors to manipulate features based on the size of the container
rather than the size of the window.
</p>
</section>

</section>

<section id="map-viewers-capabilities-custom-styling">
<h3>Custom styling</h3>

<section id="capability-styled-features" data-ucr-role="capability">
<h4>Apply custom styling to map markers and vector features</h4>
<p>
When available as an option for map authors,
custom styling should be set in a declarative way.
Map markers can be either raster or vector images,
with all relevant styling properties available to them.
Vector features should have a variety of presentational properties available to style them,
similar to how SVGs are styled on the web.
</p>
<p class="issue discussion" data-number="15">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Mapbox is unique amongst the reference tools as it offers a GUI
where styling can be applied to each vector feature.
Their style editor is extremely powerful,
and styles can be applied across particular zoom ranges, data ranges,
or even through conditional logic.
</p>
<p>
Behind the scenes, Mapbox's styles are stored in a JSON object
that conforms to their own <a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/">Style Specification</a>.
The TomTom SDK for Web accepts custom styles in the format of Mapbox's Style Specification.
</p>
<p>
For the other reference tools,
custom styles can be passed in as a JavaScript object on map initialization.
There is significant overlap
between the style properties used by these example tools and properties for formats like SVG,
such as 'stroke width', 'fill', 'opacity'.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>: (as described above)
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmaps-embed</dt>
<dt>bing-maps-embed</dt>
<dd><a>no support</a>
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Related web specifications</h5>
<p>
<a data-cite="SVG2">SVG elements</a> have many styling properties,
describing the fill color or patterns as well as stroke (outline) color, size, and dashing patterns.
These are specified using CSS methods (e.g., classes and other selectors)
or directly as element attributes.
In addition, SVG 2 allows some aspects of the vector shape's geometry to be specified in CSS.
</p>
<p>
<a data-cite="HTML#custom-elements">Custom elements</a> are able to isolate styles via the Shadow DOM,
which prevents style selectors defined outside the component to match elements within it,
or vice versa, while still allowing some style inheritance.
A similar approach could be useful for scoping map specific styling to its containing element.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-styled-controls" data-ucr-role="capability">
<h4>Apply custom styling to map controls</h4>
<p>
<!-- Description of how it should work & why it is useful to users/authors of maps. -->
</p>
<p>
This capability — custom styling —
is separate from the ability of the author to create complete custom controls
which then control the map viewer using a client-side API.
</p>
<p class="issue discussion" data-number="154">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Only Leaflet.js and OpenLayers provide a method to style map controls freely.
Because these tools are JavaScript libraries and not iframe embeds,
their controls can be styled by writing CSS that overrides the default styling.
TomTom SDK inherits this capability due to it being a wrapper over Leaflet.js.
</p>
<p>
The Google Maps API provides limited options when it comes to styling map controls.
The map author has the ability to set which form the controls take (dropdown or horizontal bar),
and set the position of the controls.
</p>

<dl data-ucr-role="implementation-notes">
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dd><a>full support</a></dd>
<dt>google-maps-api</dt>
<dd><a>supported, with limitations</a></dd>
<dt>google-maps-embed</dt>
<dt>openstreetmaps-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>no support</a>:
  <!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Related web specifications</h5>
<p>
<a data-cite="HTML#custom-elements">Custom elements</a> are encapsulated pieces of functionality
that can inherit styling from the context that they are in.
[[[css-shadow-parts-1]]] allows web component authors to expose named parts
within their custom element's shadow DOM, for styling by the web page author.
A custom element based approach would allow for map authors to style the map controls
without requiring them to implement the logic behind them manually.
</p>
<p>
<a data-cite="HTML#the-input-element">HTML form elements</a> have traditionally lacked ways for web developers to style them,
which has led to developers implementing their own versions of form elements in order to apply their own styling,
often to the detriment of semantics and accessibility.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-custom-controls" data-ucr-role="capability">
<h4>Toggle whether default controls are displayed</h4>
<p>
Custom styling isn't always enough;
sometimes an author wants to completely replace the default control buttons.
Replacing the full functionality of the controls requires a
<a href="#client-apis">client-side API</a>, discussed separately.
This capability focuses solely on the ability to declaratively control
whether or not the web browser includes on-screen controls by default.
</p>
<p class="issue discussion" data-number="16">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Amongst the reference tools that support this capability,
toggling the visibility of default controls is as simple as
setting a boolean in a configuration object.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>: (as described above)
</dd>
<dt>mapbox-embed</dt>
<dd>
  <a>partial support</a>: you can toggle controls for the HTML slippy map, but not maps created in the more robust Mapbox Studio editor.
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmaps-embed</dt>
<dt>bing-maps-embed</dt>
<dd><a>no support</a>:
  <!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
HTML Media Elements (which consists of the <code>&lt;video&gt;</code> and <code>&lt;audio&gt;</code> element)
include a <a data-cite="HTML#attr-media-controls">controls</a> attribute that indicate whether or not the author would like the user agent to display controls.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

</section>

</section>

<section id="client-apis">
<h2>Client-side Mapping API Capabilities</h2>
<p>
Client-side Mapping APIs (application programming interfaces)
allow website developers to create customized map viewers,
or other geographic applications.
Existing APIs are JavaScript libraries that offer
ready-to-use functions for fetching or rendering parts of a map,
or for manipulating a map-viewer widget.
A built-in web map solution would need to expose similar DOM APIs to JavaScript code.
</p>

<section id="client-apis-creation">
<h3>Creating maps and map components</h3>
<section id="capability-create-initialise-and-display-a-map" data-ucr-role="capability">
<h4>Create, initialise, and display a map</h4>
<p>
This is the starting point for all API usage.
</p>
<p class="issue discussion" data-number="55">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Implementations differ in how much is expected of the developer wishing simply to initialise and display a map.
Those APIs that are tightly bound to a single source of mapping data
tend to provide a single method call with options for configuration,
whereas APIs that are data-provider-agnostic at least require initialisation of data sources in addition.
</p>
<p>
Implementations also differ in the sources and types of mapping data they support.
Tiled raster map layers, with additional support for vector layers to provide supplementary content such as routes,
are widely supported.
Some implementations also support rendering maps using tiled vector map layers or untiled vector data.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dd>
<p><a>full support</a>:
Google, Bing, MapKit and TomTom  allow straightforward creation of a map with configuration options.
</p>
<p>
Leaflet, OpenLayers, and MapBox require explicit construction of objects defining the map layers
and viewport, with sensible defaults for creation of, for example, a map showing OpenStreetMap tiles
in a standard [[[WGS84]]] projection.
This provides added flexibility, at the expense of increasing the complexity of code that uses these libraries.
</p>
</dd>
<dt>d3-geographies-api</dt>
<dd>
<p><a>supported, with limitations</a>:
The <var>d3-geo</var> module supports vector data in the form of either GeoJSON or TopoJSON.
It renders this data to either an SVG or Canvas element.
It requires the developer to implement support for interaction using other d3 modules, such as <var>d3-zoom</var>
and <var>d3-transition</var>.
</p>
<p>
By utilising the <var>d3-tile</var> module, tiled raster data can be combined with vector map data.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
Leaflet, OpenLayers, and MapBox allow for the creation of layers displaying non-geographical raster tiles.
</p>

<h5>Related web specifications</h5>
<p>
The <a data-cite="HTML"></a> specifies a number of aspects of elements
that embed media in a web page and expose JavaScript APIs to enable interaction and dynamic configuration.
</p>
<p>
The <a data-cite="DOM"></a> provides interfaces for creating
HTML elements, which are what these implementations are using under the hood.
</p>
<p>
<a data-cite="SVG"></a> provides interfaces for creating vector graphics.
These are used as one of the available primary methods of rendering map data by <var>d3-geo</var>,
and for rendering supplementary content by other implementations.
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>
<p>
<a data-cite="rfc7946"></a> defines a method for representing geographical data in JSON.
This is one of the primary data formats supported by d3-geo and is also used by other implementations
for representing additional content.
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>
<p>
[[[DOM]]] [[[HTML]]] [[[SVG]]] [[[rfc7946]]]
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
Incorporating this functionality of existing map libraries in HTML would benefit users
by reducing download size and time to interactivity. Web developers would benefit from
being able to program against a standard interface.
</p>
<p>
However, it is to be expected that a native HTML web map element would be constructed
and initialised via existing DOM interfaces such as <var>document.createElement</var>
and <var>DOMElement.insertAdjacentHTML</var>. Additional aspects of the map element's
configuration might be achieved either through existing <var>DOMElement</var> interfaces
such as <var>setAttribute</var>, or through element-specific attributes and methods;
<i>cf.</i> the attributes and methods of the <var>HTMLMediaElement</var>.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="">accessibility-potential</a>
A native implementation would be better able to incorporate a semantically meaningful representation of a map
into its accessibility tree than current implementations,
which depend on the accessibility features of more general native elements in conjunction with [[[wai-aria-1.1]]].
</li>
<li><a data-ucr-role="tag" href="">performance-potential</a>
A native implementation would be more efficient in avoiding the need to download code,
in code execution,
and potentially in avoiding the necessity of creating complex DOM structures to build the map's representation.
</li>
<li><a data-ucr-role="tag" href="">author-simplicity</a>
At present, authors need to decide on an implementation to use and to learn how to use it.
They may then be unwilling to switch to an alternative implementation
for applications in which it would be more suitable.
Knowledge of and experience with a standardised native implementation would be more widely applicable.
</li>
<li><a data-ucr-role="tag" href="">author-cost-cutting</a>
Although there are free implementations available,
many authors make use of paid implementations whether through inertia or the desire for a paid support route.
A native implementation would reduce the operating costs of paid map implementation providers,
though they could continue to charge for other services such as tile servers and support,
and those savings could (in an ideal world) be passed on to their customers.
</li>
<li><a data-ucr-role="tag" href="">consistency-fallbacks</a>
Existing implementations fail if JavaScript is disabled in the user's browser,
or if connectivity failure prevents the necessary scripts being downloaded.
A native implementation would be able to at least display an initial view of a map under such conditions,
even if further enhancements intended by the author failed to be applied.
</li>
</ul>
</section>

<section id="capability-add-marker-or-multiple-markers-map" data-ucr-role="capability">
<h4>Add a marker or multiple markers to a map</h4>
<p>
Markers are discussed in more detail at <a href="#capability-marker-points"></a>.
The APIs provided for adding markers to a map generally allow a developer to use default icons
or to specify their own, to specify a short label such as a letter or number to be displayed
within a marker, and to attach annotations which are displayed when the marker is selected by the user.
</p>
<p class="issue discussion" data-number="56">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
<p>
These implementations all provide straightforward APIs for adding markers to locations using a default icon.
</p>
</dd><dt>open-layers-api</dt>
<dd><a>supported, with limitations</a>:
<!-- details about what is/isn't supported -->
<p>
Rather than providing a straightforward API, OpenLayers requires a number of steps to be followed:
providing icon imagery (as there is no default imagery provided),
creating icon features, creating a map layer to hold those features, and finally adding the layer to a map.
This is noticeably more complex than the APIs provided by a number of other implementations.
</p>
</dd><dt>d3-geographies-api</dt>
<dd><a>partial support</a>:
<!-- details about what is/isn't supported -->
<p>
By default, d3-geo will render point features as circles.
These can be styled using whatever techniques are being used to style the map content,
typically either using presentational SVG attributes, or CSS.
In practice, adding markers in a manner similar to that offered by other mapping APIs might best be achieved
by dynamically creating a GeoJSON feature containing the point features in a FeatureCollection
and adding this as an additional layer on the map.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
In cases where non-geographical data is being displayed,
markers could indicate points of interest in the same way that they do on maps.
</p>

<h5>Related web specifications</h5>
<p>
<a data-cite="rfc7946"></a> defines a method for representing geographical data in JSON.
This is one of the primary data formats supported by d3-geo and is also used by other implementations
for representing additional content.
For adding markers to a map, a GeoJSON FeatureCollection containing one or more points can be used.
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>
<p>
[[[rfc7946]]]
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
Incorporating this functionality of existing map libraries in HTML would benefit users
by reducing download size and time to interactivity. Web developers would benefit from
being able to program against a standard interface.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="">accessibility-potential</a>
Existing implementations vary widely in how they implement markers and annotations.
This lack of consistency has the potential to lead to accessibility issues,
as there may be no clear way for the information the marker is intended to denote to be accessed by assistive
technologies.
A native implementation could expose clearly-defined interfaces for accessing the meaning of the marker
and the content of any related annotation.
</li>
<li><a data-ucr-role="tag" href="">accessibility-author-context</a>
Although a native implementation could make it easier to expose related content in annotations,
it would still be incumbent on authors to ensure that such content was presented in well-structured HTML
for assistive technologies to be able to make best use of it.
</li>
<li><a data-ucr-role="tag" href="">i18n-potential-geo</a>
Assuming the fundamental content of a marker is its location,
a native implementation would be able to present that in a form appropriate for a user's locale.
</li>
<li><a data-ucr-role="tag" href="">author-simplicity</a>
A consistent interface for creating and showing markers and annotations would be advantageous
compared to the widely-varying approaches used by existing implementations.
</li>
<li><a data-ucr-role="tag" href="">author-custom-design</a>
By providing suitable interfaces for specifying the appearance of markers and annotations,
a native implementation could allow authors to ensure they were consistent with the overall design of their site.
</li>
</ul>
</section>

<section id="capability-implement-a-custom-control" data-ucr-role="capability">
<h4>Implement a custom control</h4>
<p>
Controls are user interface elements that enable interaction with the map.
Map implementations typically provide a number of default controls supporting interactions such as zooming
and switching layers.
</p>
<p>
A map implementation will typically provide the developer with various options for configuring controls.
This will include such capabilities as adding and removing controls, showing or hiding them,
and being notified of changes in their state.
It is also necessary to provide support for controlling the positioning of controls,
to avoid the situation where two controls occupy the same position on the map's UI.
</p>
<p>
Developers may wish to implement additional controls, either replacing the functionality of the map's default controls,
or adding new functionality.
Map implementations should provide APIs to support such custom controls,
allowing them to integrate fully with the map at a level that is on a par with the map's own controls.
</p>
<p class="issue discussion" data-number="57">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Support for controls varies widely among existing map implementations.
It is generally the developer's responsibility to create a suitable DOM construct,
styled with CSS and augmented with JavaScript to provide behaviour, for use as a control.
But though some implementations specify detailed APIs which controls should support
in order to be properly integrated with the map, others provide minimal support and expect the
developer to take full responsibility for responding to control lifecycle transitions.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dd><a>full support</a>:
<p>
All of these implementations fully support the concept of controls,
including support for control implementations to be notified when they are added to or removed from the map,
so they can update their own internal state accordingly.
They also allow controls to request their desired positioning within the map's UI,
and will position controls using sensible defaults if developers choose not to implement that capability.
</p>
<p>
MapBoxGL specifies an interface to which controls are expected to conform.
The map API provides methods for adding and removing controls to and from the map UI.
</p>
<p>
Leaflet, TomTom (which uses Leaflet), and OpenLayers provide base classes which controls extend,
along with map methods for adding and removing controls.
OpenLayers also exposes its control collection directly.
</p>
</dd>
<dt>google-maps-api</dt>
<dd><a>supported, with limitations</a>:
<p>
While Google Maps supports the adding and removing of controls and the specifying of their placement
within a number of predefined areas within the map's UI,
there is no specific interface to which they are expected to conform.
</p>
</dd>
<dt>bing-maps-api</dt>
<dd><a>partial support</a>:
<p>
Bing Maps expects controls to be implemented as a type of overlay.
It provides no particular support for controls beyond that, not even for positioning them within the map UI,
which is left to the developer to achieve using CSS positioning.
</p>
<dt>apple-mapkit-js-api</dt>
<dd><a>no support</a>a>:
<p>
Apple MapkitJS does not provide an interface that can be implemented to create a custom control,
nor does it have any generic mechanism for adding and removing controls beyond those provided.
</p>
</dd>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
<p>
Although d3 supports a variety of user interactions, the concept of a user interface presenting a collection
of controls to the user is not part of the library.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
As controls are explicitly intended as part of the map's user interface,
further uses for the concept might be found in other cases
where complex interactive content is presented by an element, such as adding controls to media containers.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
It might seem that, as controls are implemented using existing interactive HTML elements,
there is no pressing need for them to be supported by additional APIs.
However, the need for them to be closely integrated with a map's own UI, state, and lifecycle
suggests that this functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="">accessibility-potential</a>
Differences in implementation by existing libraries can lead to accessibility issues which would be averted
by a native implementation that exposed controls in a way consistent with other user interface elements.
</li>
<li><a data-ucr-role="tag" href="">accessibility-info-needed</a>
It is unclear how custom controls could be implemented in a manner which guarantees the accessibility benefits
of native map controls.
</li>
<li><a data-ucr-role="tag" href="">accessibility-author-context</a>
To implement accessible custom controls,
authors would have to take into account the same considerations as apply to implementing interactive elements
in other parts of the web platform.
</li>
<li><a data-ucr-role="tag" href="">i18n-potential-text</a>, <a data-ucr-role="tag" href="">i18n-localized-UI</a>
A native implementation would be able to label controls according to the user's configured locale.
</li>
<li><a data-ucr-role="tag" href="">author-extensibility</a>
If a suitable interface were defined for authors to implement,
it has the potential to simplify the creation of custom controls that require access to the map's state.
</li>
</ul>
</section>

<section id="capability-add-layer-map" data-ucr-role="capability">
<h4>Add a layer to a map</h4>
<p>
Adding a layer to a map viewer is a fundamental capability,
as without it the base layer itself could not be added to the viewer.
While map viewer implementations from a provider of mapping data can be expected to automatically add
a base layer showing the data they provide, other implementations require a base layer to be explicitly
created and added to the map as part of its initial configuration.
</p>
<p>
Adding further map layers other than the base layer allows additional information to be presented to the user
in  geographical context.
</p>
<p class="issue discussion" data-number="61">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All of the reviewed APIs support the creation of alternative base layers for the map,
and the addition of layers to the base map. Both raster and vector layers are supported.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>bing-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>tomtom-sdk</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
<p>
The implementations from mapping data providers generally require additional configuration to be specified
in the case where an alternative base layer that does not use their data is provided.
</p>
</dd>
</dl>
<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
As a map viewer provides the ability to pan and zoom imagery covering a large extent, there are many alternative
uses. Some examples include works of art that have been digitised at ultra high resolution,
allowing anyone to examine them in fine detail, and ultra high resolution panoramic photographs.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the fundamental nature of this capability, it is a <a data-ucr-role="conclusion">requirement</a> for web map APIs.
In addition to providing basic and extended capabilites for the display of geographic data,
it also allows the repurposing of such APIs for wider application.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="#author-extensibility"></a>
This capability promotes extensibility by allowing authors to incorporate additional or alternative data into a map.
</li>
<li><a data-ucr-role="tag" href="#author-custom-design"></a>
This capability allows for customization of both base maps and additional data presented on the map,
thereby giving authors flexibility to customize the appearance of maps to suit the design of the site on which the map is displayed.
</li>
</ul>
</section>

<section id="capability-define-data-source-tile-layer" data-ucr-role="capability">
<h4>Define a data source for a tile layer</h4>
<p>
Existing commercial implementations will generally show map data from a preconfigured source,
while open-source implementations will either provide or document an initial configuration using open map data.
But many applications require the use of alternative sources of map data,
and it is therefore necessary that a map implementation provide suitable APIs for the configuration of such sources.
</p>
<p>
Configuring alternative data sources is also necessary to support the display of non-geographic tiled imagery.
</p>
<p class="issue discussion" data-number="74">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<p>
All implementations support the creation of a layer with a specified data source that conforms to an OWS standard.
This requires specifying a way for the layer to access the data source,
which is achieved by specifying which OWS protocol to use along with a URL template.
Some implementations support the use of a URL template function to return the required tile URLs
when invoked with arguments specifying the geographical position and extent the required tile should represent.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
All uses of map implementations to display non-geographical imagery require this capability.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the fundamental nature of this capability, it is a <a data-ucr-role="conclusion">requirement</a> for web map APIs.
In addition to allowing for the display of alternative geographic data,
it also allows the repurposing of such APIs for wider application.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="">accessibility-potential</a>
Alternative visual representations such as high-contrast map data
can improve accessibility of maps for those with certain visual impairments.
</li>
<li><a data-ucr-role="tag" href="">i18n-potential-text</a>
Alternative map imagery supporting different languages and/or alphabets than that assumed to be appropriate by the
default map data source can be provided.
</li>
<li><a data-ucr-role="tag" href="">i18n-potential-geo</a>
Alternative data sources would allow for the use of map data that reflects regional variations
in perceived relevance of mapped features,
expected depictions of features,
and political differences concerning the location of regional boundaries.
</li>
<li><a data-ucr-role="tag" href="">author-extensibility</a>
A website wishing to display geographic data that is outside the remit of general-purpose mapping services
requires such a capability.
</li>
<li><a data-ucr-role="tag" href="">author-custom-design</a>
Displaying custom tile data that reflects the aesthetics of a site requires such a capability.
</li>
<li><a data-ucr-role="tag" href="">author-independence</a>
A website author can use this capability to provide their own map imagery
independently of third-party map data providers.
</li>
</ul>
</section>

<section id="capability-create-an-overlay-defined-by-vector-data" data-ucr-role="capability">
<h4>Create an overlay defined by vector data</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="155">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<p>
All of the API-based map viewer implementations support the use of vector data defined in a number of standard formats,
such as GeoJSON and KML.
When topogeographical data is available that is not already in one of the widely-supported formats,
application developers can readily convert that data into object structures that can be utilised by the existing APIs,
such as the structure of a GeoJSON object.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps,
as there are numerous sources of such data.
Furthermore, vector data allows a level of precision higher than that achievable with raster data,
or that it may not be convenient or possible to present in the form of rasters.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="#author-simplicity"></a>:
existing implementations mostly allow vector data to be incorporated into a map view with a single method call,
making it easy for web authors to utilise such data.
</li>
<li><a data-ucr-role="tag" href="#author-custom-design"></a>:
the styling of vector data is in the hands of authors,
allowing them to easily match it to the design of the containing site.
</li>
<li><a data-ucr-role="tag" href="#author-extensibility"></a>:
this capability allows authors to incorporate high precision data representations over a base map.

</li>
<li><a data-ucr-role="tag" href="#consistency-progressive"></a>:
vector data can be incorporated into an HTML document as a list, table, microformat metadata, or similar structured content.
The data can then be extracted by a script, formed into a suitable object structure (such as GeoJSON),
and rendered on the map.
</li>
</ul>
</section>

<section id="capability-create-an-overlay-defined-by-heatmap-data" data-ucr-role="capability">
<h4>Create an overlay defined by heatmap data</h4>
<p>
Point intensity data is a useful way of representing the distribution of a phenomenon across geographical areas.
Examples include frequency of earthquake occurrence in different regions,
the distribution of types of vegetation found in an area,
or the spread of a global pandemic at a particular point in time.
</p>
<p>
It is possible to preprocess such data into a raster or vector format for display,
but giving a map implementation the capability of rendering such data into an overlay directly
averts such problems as maintaining consistency between multiple representations of the same data.
Implementations will commonly accept point intensity data defined in a number of standard vector data formats,
such as KML or GeoJSON.
</p>
<p class="issue discussion" data-number="156">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>mapbox-gl-api</dt>
<dt>open-layers-api</dt>
<dd><a>full support</a>:
<p>
All of these implementations support the display of point intensity data as a heatmap.
In the case of Google Maps, it is necessary to specify the inclusion of support declaratively when loading the
script library.
Typically, a vector data source object is defined in JavaScript either by specifying the URL of a resource
or by specifying the data directly in code.
</p>
</dd>
<dt>bing-maps-api</dt>
<dt>leaflet-api</dt>
<dt>tomtom-sdk</dt>
<dt>d3-geographies-api</dt>
<dd><a>partial support</a>:
<p>
Bing Maps has native support for heatmaps via a separate module that must be explicitly loaded in JavaScript,
rather than being specified declaratively in HTML.
Leaflet (and by extension TomTom) and d3 have third-party plugins available which add support.
</p>
</dd>
<dt>apple-mapkit-js-api</dt>
<dd><a>not applicable</a>:
<p>
MapKit JS does not support a heatmap overlay at present,
and no third-party plugins adding support are known of.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
Heatmaps have existing applications unrelated to geography in a number of fields.
For example, they are used in molecular biology for such purposes as visualizing gene expression.
An implementation capable of displaying non-geographic point intensity data would therefore
have potential value in the display of such data on the web.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="">accessibility-potential</a>
Existing implementations only allow access to the underlying data represented by a heatmap
if the author explicitly provides it, for example by also including the source data in an HTML table.
A native implementation has the potential to improve access to the data.
Furthermore, the choice of colours used in the heatmap may present problems for users with
visual impairments.
A native implementation could expose controls to allow users to select an alternative palette,
such as a  high-contrast version.
<li><a data-ucr-role="tag" href="">performance-potential</a>
Rendering a heatmap from data can be computationally expensive,
and it may be possible for a native implementation to achieve greater efficiency.
</ul>
</section>

<section id="capability-control-layers-map" data-ucr-role="capability">
<h4>Control which layers are included in a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="63">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>tomtom-sdk</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
All of these implementations allow hiding and showing a layer on a map.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-specify-style-map" data-ucr-role="capability">
<h4>Specify the style of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="65">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-determine-current-style-map" data-ucr-role="capability">
<h4>Determine the current style of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="66">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>
</section>

<section id="client-apis-map-viewport">
<h3>Controlling the displayed map view and responding to user actions</h3>

<section id="capability-get-bounds-map" data-ucr-role="capability">
<h4>Get the bounds of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="60">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-pan-zoom-or-re-centre-map" data-ucr-role="capability">
<h4>Pan, zoom, or re-centre a map</h4>
<p>
Developers expect to be able to control a map by changing its centre and/or zoom level,
and may also wish to support the capability of resetting a map to its view as originally presented.
If the map view cannot be dynamically modified by an application,
as opposed to changes by direct user interaction with the map,
then it offers fewer advantages over a static map view.
</p>
<p>
It is usually also desirable that such changes can be accomplished in a manner that gives sufficient
visual feedback to the user that a change is occurring,
for example by animating the transition rather than simply redrawing the map with the new view,
which may not be immediately noticeable to the user.
</p>
<p>
Accessibility is an important consideration when the state of a map is altered dynamically.
Thought should be given to how the change can be made known to assistive technologies so that the user
is fully informed and thus cognisant of the current state of the map at all times.
</p>
<p class="issue discussion" data-number="67">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All the reviewed JavaScript API implementations support changing the bounds, centre, and zoom level of a map,
and allow such transitions to be animated.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
<p>
Animated transitions are supported by calling specific methods with names such as <code>flyTo</code>
or via a Boolean parameter to a more general method such as <code>setView</code>.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
This capability would be relevant to use of web map technology for the display of non-geographic imagery,
such as navigating the view to relevant parts of a complex diagram as the user progresses through related content.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
<a href="https://github.com/w3c/csswg-drafts/issues/5275">
[css-overflow] Consider adding new CSS primitive for per-element panning and zooming (for web maps) #5275
</a>
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
As this is capability is required for any dynamic update of a map view such as would be expected of a map-based application,
it is a <a data-ucr-role="conclusion">requirement</a> for embedded web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="">privacy-potential</a>
As there is the potential for third-party scripts to observe the panning and zooming of a map,
there is a risk with current implementations of this feature exposing an individual's or corporation's
interest in particular locations.
This risk would be mitigated with appropriate browser-level security.
</li>
<li><a data-ucr-role="tag" href="">accessibility-potential</a>
Current implementations can only represent changes in the map state in a semantically meaningful form
to a limited degree via such mechanisms as [[[wai-aria-1.1]]] <a href="https://www.w3.org/TR/wai-aria/#dfn-live-region">live regions</a>.
A browser implementation would be better able to provide meaningful representations of such changes to assistive
technologies.
</li>
<li><a data-ucr-role="tag" href="">performance-potential</a>
As current implementations rely on extensive manipulation of DOM nodes to achieve these effects,
it is probable that a native implementation would be much more efficient.
</li>
</ul>
</section>

<section id="capability-map-events" data-ucr-role="capability">
<h4>Subscribe to notifications of map events</h4>
<p>
A web application embedding a map will commonly need to respond to changes in the state of the map,
whether as a result of user activity or from other causes,
so that it can update its own internal state and user interface as necessary to remain consistent with the map view.
At a minimum, any change of the area displayed by the map needs to be notified to the application.
In practice, it is usually desirable for other high-level events within the map view to be exposed as well.
This allows an application fine-grained control of the level of detail of interactions it responds to,
from simple updates when the map is moved or the zoom level is changed,
to detailed feedback during user interactions of longer duration such as continuous panning.
</p>
<p>
In addition to events relating to the state of the map view itself,
developers will expect to be able to receive notifications of events triggered by other components within the map
such as controls, markers, and layers.
</p>
<p>
A native HTML map element would be expected to support the existing DOM event binding interface,
using the standard <code>addEventListener()</code> method to bind listener functions to map events,
and receiving an object derived from the standard <code>Event</code> interface
as the argument to such functions.
</p>
<p class="issue discussion" data-number="69">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>
Implementations of map events vary widely in both the terminology used and the semantic richness of the events available.
For example, the Google Maps API provides events named <code>center_changed</code>
and <code>zoom_changed</code>, allowing a developer to provide discrete event handlers for such changes.
The Leaflet API supports similar events, but named <code>moveend</code> and <code>zoomend</code>.
The Bing Maps API, on the other hand, provides a more general <code>viewchangeend</code> event,
and the handler for this event must examine the state of the map to determine what has changed.
</p>
<p>
APIs generally also provide lower level events directly correlating to user interactions,
such as <code>click</code> and <code>mouseover</code> in the Google Maps API, though again terminology varies.
The event objects passed to handlers of such events have additional properties compared to their equivalents
in normal DOM event handling, such as a property giving the position of the event in terms of latitude and longitude.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>d3-geographies-api</dt>
<dd><a>supported, with limitations</a>:
<!-- details about what is/isn't supported -->
<p>
Although all existing implementations support an events system capable of meeting the needs of developers,
inconsistencies in terminology, semantic richness, and the interfaces provided for adding and removing
event listeners mean that it is unclear whether any one of the existing APIs would be a suitable model
for the various capabilities available across the entire range of them.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
As it is anticipated that standard DOM event interfaces would be the basis for an HTML map's event system,
it is likely that further uses could arise for such capabilities.
For example, an HTML text annotated with geographical microdata could allow DOM events arising from user interaction
(such as clicking on the name of a city within the text) to be enhanced with the same kind of position property,
specifying latitude and longitude, as would be present in an event object created by a similar interaction
with a map element.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
As outlined above, it is expected that events as defined in [[[DOM]]] would form the basis for a map element's
event system.
</p>
<p>
[[[HTML]]] media objects provide an existing example of extending the basic event system to support
particular capabilities of embedded content.
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This capability is a <a data-ucr-role="conclusion">requirement</a> for the scripting API of a native HTML map element.
Responding to changes in the state of a map, or user interactions with elements of the map such as markers,
is necessary for a web application to usefully modify its own state so as to reflect the results of such interactions.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href="">privacy-sensitive-data-revealed</a>
Collating the positions on which a user centres the map could allow a script to infer an interest
in a particular region and, for example, target advertising accordingly.
</li>
<li><a data-ucr-role="tag" href="">accessibility-potential</a>
If events from maps and map interface elements are exposed to assistive technologies via the browser's
existing accessibility mechanisms, it would be easier for those technologies to present them in a way
consistent with other browser interactions.
</li>
<li><a data-ucr-role="tag" href="">performance-potential</a>
Existing implementations must perform complex tasks such as transforming browser coordinates to map coordinates
in order to provide such data in enhanced event objects.
Native implementations could be expected to provide significantly better performance.
</li>
<li><a data-ucr-role="tag" href="">author-extensibility</a>
The ability to respond to user interaction is crucial in building rich application interfaces that include embedded maps.
</li>
<li><a data-ucr-role="tag" href="">author-cost-cutting</a>
A standardised interface against which to write event-driven mapping applications reduces the amount of time developers
need to spend becoming competent and productive.
</li>
<li><a data-ucr-role="tag" href="">consistency-match</a>
Current implementations already seek to either extend or mimic the existing event mechanism.
</li>
<li><a data-ucr-role="tag" href="">consistency-progressive</a>
An application can determine which event-driven enhancements it is capable of supporting in a given environment.
</li>
<li><a data-ucr-role="tag" href="">consistency-fallbacks</a>
An application can choose not to subscribe to a given event or events if it determines that it cannot usefully
provide an enhancement in its current environment.
</li>
</ul>
</section>

<section id="capability-change-bearing-map" data-ucr-role="capability">
<h4>Change the bearing of a map</h4>
<p>
Although the default bearing of a map - that is, the direction of "up" - is usually north,
it can be useful to change this.
</p>
<p class="issue discussion" data-number="72">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>open-layers-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
these implementations all permit the bearing of a map view to be changed.
</dd>

<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>leaflet-api</dt>
<dd><a>no support</a>:
these implemtations provide no support for changing the bearing of the map.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
This capability could be useful when a map viewer is used to display zoomable technical drawings.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
  This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future.</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>


<section id="capability-move-the-map-to-display-a-given-location" data-ucr-role="capability">
<h4>Move the map to display a given location</h4>
<p>
An API should support allowing the map to be moved to
display a given location.
</p>
<p class="issue discussion" data-number="157">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-pan-and-zoom-to-bounding-box" data-ucr-role="capability">
<h4>Pan and zoom a map so as to completely show the area covered by a given bounding box</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="158">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-animate-the-re-centering-of-the-map-view" data-ucr-role="capability">
<h4>Animate the re-centering of the map view</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="159">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-animate-the-zooming-of-the-map" data-ucr-role="capability">
<h4>Animate the zooming of the map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="160">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-animate-the-re-centering-of-the-map" data-ucr-role="capability">
<h4>Animate the re-centering of the map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="161">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

</section>
</section>

<section id="map-formats">
<h2>Map Data Formats for Map Viewers</h2>
<p>
Many different types of spatial data can be integrated in a web map:
satellite imagery,
cartographic representations of roads and terrain,
3D building profiles,
pinpoint locations with annotated descriptions,
route directions or other polyline paths,
and more.
Many standard and proprietary formats exist to describe this data.
</p>
<p>
A built-in web map viewer will need to work with spatial data
that is already available from web servers,
or that can be provided with minor server upgrades.
</p>

<section id="map-formats-vector">
<h3>Vector feature data formats</h3>

</section>

<section id="map-formats-projections-crs">
<h3>Map projections and coordinate reference systems</h3>

</section>

<section id="map-formats-server-apis">
<h3>Server APIs</h3>

</section>
</section>

<section id="requirements">
<h2>Summary of Requirements</h2>
<p>
<i>To Do: finish the script to generate a summary table from the annotated markup.</i>
</p>
</section>

<section class="appendix" id="issue-summary">
<h2>Open Issues</h2>
<p>
We are tracking issues on <a href="https://github.com/Maps4HTML/HTML-Map-Element-UseCases-Requirements/issues">Github</a>.
</p>
</section>

<section class='appendix'>
<h2>Acknowledgments</h2>
</section>


<script id="preprocess" class="remove">
;(()=>{/* closure */

const slugify = (s) => s.toLowerCase().replace(/[\W_]+/g, "-");
const uniqueValues = (array) => Array.from(new Set(array));
function dictFromArray(array, idProp="id") {
  return array.reduce((dict, item)=>(dict[item[idProp]]=item, dict), {});
}

const htmlFragmentFromString = (s, contextNode=document.body) => {
  let r = document.createRange();
  r.selectNode(contextNode);
  return r.createContextualFragment(s);
}

function processTagDfn(node) {
  let tagType = (node.getAttribute("data-ucr-tag-type")||"unknown").trim();
  node.innerHTML = `<span class="tag-span tag-${tagType}">${node.innerHTML}</span>`;
  let tagNode = node.firstChild;
  return { dfnNode: node, tagNode, tagType, id: node.id };
}
let tagDfns = [...document.querySelectorAll("[data-ucr-role='tag-dfn']")]
  .map( processTagDfn );
let tagDfnDict = dictFromArray(tagDfns);
let conclusionDfns = [...document.querySelectorAll("[data-ucr-role='conclusion-dfn']")]
  .map( processTagDfn );
let conclusionDict = dictFromArray(conclusionDfns);

function findSectionTitle(node) {
  let heading = node.querySelector("h2,h3,h4,h5,h6")
        || node.firstElementChild || node;
  return heading.textContent.trim();
}
function processUseCase(node) {
  let name = findSectionTitle(node);
  let id = node.id || (node.id = "use-case-" + slugify(name));
  return { node, name, id };
}
function processCapability(node) {
  let name = findSectionTitle(node);
  let id = node.id || (node.id = "capability-" + slugify(name));

  let conclusionNode = node.querySelector("[data-ucr-role='conclusion']");
  let conclusion = conclusionNode?
    (conclusionNode.getAttribute("data-lt") || conclusionNode.textContent)
    : "undecided";
  if (conclusionNode) processTag(conclusionNode, conclusionDict);

  // extract the “supported use cases” & generate cross references
  const capabilityUseCasesList = node.querySelector("ul[data-ucr-role='capability-uses']");
  if (capabilityUseCasesList) {
    const supportedUseCaseLinks = [...document.querySelectorAll(`[data-ucr-role='required-capabilities'] [href='#${id}']`)];
    supportedUseCaseLinks.forEach((link) => {
      const useCase = link.closest("[data-ucr-role='use-case']");
      const a = document.createElement('a');
      a.href = `#${useCase.id}`;
      const li = document.createElement('li');
      li.appendChild(a);
      capabilityUseCasesList.appendChild(li);
    });
  }

  return { node, name, id, conclusion,
           tags: [], implementations: {} };
}
function processTag(node, dict) {
  let tagDfnId = node.hash? node.hash.replace(/^#/, "")
                       : node.textContent.trim();
  let tagDfn = dict[tagDfnId];
  if (!tagDfn) return null;
  if (!node.hash) node.href = "#" + tagDfnId;
  node.textContent = "";
  node.appendChild( tagDfn.tagNode.cloneNode(true) );
  return tagDfn;
}

let useCases = [...document.querySelectorAll("[data-ucr-role='use-case']")]
  .map( processUseCase );

let capabilities = [...document.querySelectorAll("[data-ucr-role='capability']")]
  .map( processCapability );

capabilities.forEach((capability)=>{
  let tags = [...capability.node.querySelectorAll("[data-ucr-role='tag']")]
    .map( (node)=>processTag(node, tagDfnDict) );
  capability.tags = uniqueValues(tags).filter(Boolean);
});

/* TODO, build a summary table from all the capability data */

document.documentElement.classList.add("processed");
})();/* closure */
</script>

<template id="tag-dfn-template" style="display: none" class="remove">
<!-- Markup template for adding a new tag to the guiding principles section.
     The `id` is essential & is what will be used to link to the tag.-->
<li>
<dfn id=""
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good|caution|bad">Category: description</dfn>
indicates <!-- longer description -->
</li>
</template>

<template id="use-case-template" style="display: none" class="remove">
<!-- Markup template for each use case.
     Attributes starting with `data-ucr-` are used in the script.
  -->
<section id="use-case-***" data-ucr-role="use-case">
<h4><!-- Goal that user/author is trying to achieve --></h4>
<p>
<!-- Short (1-3 paragraph) description, with details on who/why this goal is important -->
</p>
<p>
See <a href="examples/#(add a new file for each use case)" target="examples">examples of <!-- description --></a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="(GH issue number for discussion)">Discuss this section on GitHub.</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href=""></a></li>
</ul>
</section>
</template>

<template id="capability-template" style="display: none" class="remove">
<!-- Markup template for each capability, include as many as required for each use case -->
<section id="capability-***" data-ucr-role="capability">
<h4><!-- Action that is/should be possible --></h4>
<p>
<!-- Description of how it should work & why it is useful to users/authors of maps. -->
</p>
<p class="issue discussion" data-number="(GH issue number for discussion)">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>
<!-- Summarize how this capability is implemented in the reference tools,
    including common patterns, notable differences, and any limitations.
    Specific details for each should be given in the list that follows.
    Wherever possible, include the implementation in the example file for the use case -->
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
     Give details about what is/isn't supported in the dd element,
     starting with a link to one of the implementation levels.
     List full implementations first.
     Group implementations (multiple dt for the same dd) when they have the same support.
  -->
<dt>short-name-embed</dt>
<dt>short-name-api</dt>
<dd><a>full support|supported, with limitations|partial support|no support|not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
     Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
     Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
     whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
     See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
     Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>
</template>

</body>
</html>
