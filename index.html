<!DOCTYPE html>
<html lang="en">
<head>
<meta charset='utf-8'>
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Use Cases and Requirements for Standardizing Web Maps</title>
<style>
h5:not(.specificity-hack) {
  margin-top: 2rem;
  margin-bottom: 1rem;
}
a:empty::before {
  content: attr(href);
}
[data-ucr-role="tag-dfn"]::after {
  content: " (" attr(id) ")";
  font-weight: normal;
  font-style: italic;
  margin-right: 0.3em;
}
dfn {
  font-weight: bold;
  font-style: inherit;
}
.tag-span {
  display: inline-block;
  font-style: normal;
  font-weight: bold;
  line-height: 1;
  padding: 0.3em 0.5em;
  border-radius: 0.5em;
  background-color: #ccc;
}
.tag-span.tag-bad {
  background-color: #f86;
}
.tag-span.tag-caution {
  background-color: #ff8;
}
.tag-span.tag-good {
  background-color: #8fa;
}
/* cancel out the fancy link styling on links
   that will contain solid-colored tags */
.processed a[href][data-ucr-role='tag'],
.processed a[href][data-ucr-role='conclusion'] {
  border-bottom: none;
  background: none;
}
/* add link styling on the tags instead */
a[href] .tag-span {
  color: black;
}
a[href]:hover .tag-span, a[href]:focus .tag-span {
  text-decoration: underline;
}
.issue .discussion {
  font-style: italic
}
.issue.discussion[data-number]::after {
  content: " (#" attr(data-number) ")";
  /* applies if ReSpec JS doesn't run */
}
[id^="use-case-"] figure img {
  border-radius: 2px;
  height: auto;
  max-width: 100%;
  margin: auto;
  margin-bottom: .5rem;
}
.figno::after {
  content: ":";
}
</style>
<script class='remove'>
var respecConfig = {
  // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
  specStatus:  "CG-DRAFT",

  // if your specification has a subtitle that goes below the main
  // formal title, define it here
  // subtitle:  "",

  // if you wish the publication date to be other than the last modification, set this
  // publishDate:  "1999-12-31",
  copyrightStart: "2019",

  github: "https://github.com/Maps4HTML/HTML-Map-Element-UseCases-Requirements",

  // if there a publicly available Editor's Draft, this is the link
  // (calculated automatically for GitHub pages)
  // edDraftURI:  "https://maps4html.github.io/HTML-Map-Element-UseCases-Requirements/",

  // editors, add as many as you like
  // only "name" is required
  editors:  [
      {
          name:       "Amelia Bellamy-Royds",
          mailto:     "amelia.bellamy.royds@gmail.com"
      }
  ],
  authors:  [
      {
          name:       "Amelia Bellamy-Royds"
      },
      {
          name:       "Nic Chan"
      },
      {
          name:       "Nick Fitzsimons"
      },
      {
          name:       "Peter Rushforth"
      },
  ],

  // name of the WG
  wg:           "Maps For HTML Community Group",

  // URI of the public WG page
  wgURI:        "https://www.w3.org/community/maps4html/",

  // name (without the @w3c.org) of the public mailing to which comments are due
  // wgPublicList: "public-maps4html", // don't use default comment request

  localBiblio: {
    "MapML" : {
      title: "Map Markup Language",
      href: "https://maps4html.github.io/MapML/spec/",
      publisher: "Maps for HTML Community Group"
    },
    "HTML-map-element" : {
      title: "The HTML map Element proposal",
      href: "https://maps4html.github.io/HTML-Map-Element/spec/",
      publisher: "Maps for HTML Community Group"
    },
    "webcomponents-design-guidelines" : {
      title: "Guidelines for creating web platform compatible components",
      href: "https://www.w3.org/2001/tag/doc/webcomponents-design-guidelines/",
      publisher: "W3C TAG"
    },
    "WGS84" : {
      title: "World Geodetic System 1984",
      href: "http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf",
      publisher: "US National Imagery and Mapping Agency"
    }
  }
};
respecConfig.otherLinks = [
  {
    key: 'Join the Community Group',
    data: [{value: respecConfig.wg, href: respecConfig.wgURI}]
  }
]
</script>
<script src='https://www.w3.org/Tools/respec/respec-w3c-common'
        defer class='remove'></script>
</head>
<body>
<section id='abstract'>
<p>
This report outlines the use cases and requirements
for standardizing modern Web maps,
in a way that works
for map content authors, webpage authors, and website users.
The use cases and requirements were gathered in
consultation with the Maps for HTML Community Group and others.
</p>
<p>
Three aspects of web maps are reviewed:
map viewer widgets,
client-side mapping APIs,
and
map data formats.
For each, evidence is gathered from widely-used scripted JavaScript web map frameworks.
The common features and limitations of the current techniques
are the basis of the requirements for a standardized solution
that could be built in to HTML and web browsers.
</section>

<section id='sotd'>
<p>
Comments, corrections, and suggested additions should be made as
<a href="https://github.com/Maps4HTML/HTML-Map-Element-UseCases-Requirements/issues/">GitHub issues</a>.
If that is not possible, send an email comment to
<a href="mailto:public-maps4html@w3.org">public-maps4html@w3.org</a>.
</p>
</section>

<section id="introduction">
<h2>Introduction</h2>

<section id="intro-web-maps">
<h3>The current state of web maps</h3>
<p>
Web maps today are indispensable to billions of people,
for exploring and understanding the world around them.
Like paper maps before them,
web maps are used for planning, wayfinding, analysis, and more.
But the power of an interactive, hyperlinked medium
supports a richer experience than could have been imagined
by a cartographer from a previous century.
Online maps can be dynamically redrawn with new data,
or according to the user's preferences.
They can connect to other maps —
for adjacent areas, finer detail, or different geographical features —
and can link out to complex information about the places they represent.
</p>
<p>
But despite their ubiquity on the web,
maps have no native, semantic representation in HTML.
</p>
<p>
HTML has had “image maps” —
hyperlinked graphics, where selecting different parts of the graphic triggers a different URL —
<a href="https://tools.ietf.org/html/rfc1866#section-7.6">from its early days</a>.
These were quickly adopted to
<a href="https://web.archive.org/web/20110628194820/http://www2.parc.com/istl/projects/www94/mapviewer.html">represent simple cartographic maps</a>.
The <a href="https://html.spec.whatwg.org/multipage/image-maps.html#the-map-element"><code>&lt;MAP&gt;</code></a> element
sounds like it should be the basis of a web map,
but its basic functionality
(to define geometric areas on an image that represent distinct hyperlinks)
has not evolved to include many capabilities
that users today expect when interacting with maps on the web,
such as the ability to dynamically change the map view.
</p>
<p>
Web mapping technology has undergone a <a href="https://en.wikipedia.org/wiki/Web_mapping#History_of_web_mapping">long period of evolution.</a>
Today's web maps are usually sophisticated client-server applications,
dynamically combining many types of spatial data on demand for web users.
Implementations vary widely,
but some of the underlying techniques, software, semantics and formats have become
accepted patterns
(for example, <a href="https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames">the tile naming systems</a>),
or formal standards
(for example, the <a href="https://www.opengeospatial.org/standards">standards published by the Open Geospatial Consortium</a>,
some of which are also ISO standards).
</p>
<p>
Many sources of spatial data are available online,
from governments, commercial services, and non-profit projects.
But accessing and using the data is a specialized task;
most web developers or website content creators
rely on JavaScript frameworks
(or sometimes still Flash frameworks)
that can fetch the correct map image tiles or vector data,
draw them to the screen,
and handle the most common user interactions.
</p>
<p>
Many of these web map frameworks are tied to a specific commercial provider of map data,
making it difficult for website creators to integrate their own data,
or data from multiple sources.
Many of the web map frameworks do not work at all without JavaScript,
and require considerable resource downloads and processing.
The end user has limited control or customization over the map interface —
unless the website author happened to choose the web map provider
that matches the native mapping application on the end-user's device.
</p>
<p>
Web maps today may not be perfect,
but they have filled a clear need for website authors and users.
The multiple frameworks used to generate web maps
implement the same capabilities with different code —
code that needs to be downloaded and processed for each website with a map in it.
These core aspects of Web maps represent mature, ubiquitous user interface (UI)
and application programming interface (API) patterns.
It is now reasonable to consider standardizing these capabilities
for implementation by web browsers directly.
</p>
<p>
A key challenge is to do so in a way that is
compatible with the core values of the open web,
and integrated with other web platform technologies.
</p>
</section>

<section id="intro-maps4html-cg">
<h3>The Maps for HTML Community Group</h3>
<p>
The Maps For HTML Community Group (<a href="https://www.w3.org/community/maps4html/">Maps4HTML</a>)
arose as a result of face-to-face
<a href="https://www.w3.org/community/maps4html/wiki/LGD14BarCampNotes">discussions</a>
at the Linking Geospatial Data workshop 2014,
co-sponsored by the W3C and the Open Geospatial Consortium.
</p>
<p>
The group operates within the structure of a W3C community group,
with clear license terms for contributions of intellectual property.
The community group process
designed to support the eventual transition of the group's work to become open web standards.
The group attempts to follow the established best practices for web standard development,
as outlined in <a href="#principles">the guiding principles</a> for this report.
</p>
<p>
The initial requirements sketched out at LGD2014
were expanded into <a href="draft-2015.html">an initial use cases and requirements summary</a>.
That work was the basis of the draft [[[MapML]]] specification
and [[[HTML-map-element]]] proposal.
Although MapML has had notable support and development efforts
from within the geospatial community,
as of early 2019 it has not received significant support
from web browser developers or HTML standards teams.
For that reason, the current document rolls back the focus
to the discussion of mapping use cases and requirements.
The structure of this report is intended to more comprehensively explain
<em>why</em> native HTML web maps would be beneficial,
and <em>how</em> they should best be defined.
</p>
<div class="ednote">
<p>
This report is a work in progress!
Feedback and contributions are welcome.
Most sections of the report include links to a discussion issue on GitHub.
Use those issues to suggest corrections, additions,
or changes to the conclusions.
To suggest a new section (e.g., a new use case),
please start a new issue.
</p>
<p>
To make substantive contributions
(that is, anything that is bigger than typo corrections or formatting fixes),
you will need to first
<a href="https://www.w3.org/community/maps4html/">become a member of the community group</a>
and make the corresponding IP commitments.
</p>
</div>
</section>

<section id="intro-report-structure">
<h3>Structure of this report</h3>
<p>
The purpose of this report is to describe
(1) why and how the open web would benefit from having
web map features built in to web browsers,
and (2) what this native web mapping function should look like,
to website creators and to end users.
</p>
<p>
This report uses an empirical approach to identify required features of web maps,
by looking for the common features of web map frameworks used today.
However, we also recognize that web maps today have limitations.
A proposal for a native HTML web map, built in to web browsers,
needs to be assessed on the same merits as any other proposed web standard.
</p>
<p>
In <a href="#principles"></a>,
we outline the theoretical factors we use
for assessing whether a given feature should be included as a requirement.
</p>
<p>
In <a href="#use-cases"></a>,
we outline common goals for people interacting with web maps.
The use cases are defined in pragmatic terms,
describing a specific function or action.
Real-world, domain-specific applications of the use case
are summarized in an introductory description.
The use cases are divided according to whether they apply to
<a href="#content-author-use-cases">content creators</a>,
<a href="#visitor-use-cases">website visitors</a>,
or <a href="#application-use-cases">web application developers</a>.
(Of course, there is overlap between the audiences —
good developers want to create good user experiences!)
</p>
<p>
In <a href="#js-examples"></a>,
we introduce the web map frameworks that are used in the empirical review.
</p>
<p>
The review of potential requirements
is then divided into three parts:
</p>
<ul>
<li>
<a href="#map-viewers"></a>,
including the user interface
and all configuration that could be defined declaratively
in elements, attributes, and style properties.
</li>
<li>
<a href="#client-apis"></a>,
which would require additional DOM APIs
to enhance or complement the declarative elements.
</li>
<li>
<a href="#map-formats"></a>
that should be supported for representing spatial data
used by the map viewers.
</li>
</ul>
<p>
For each category, we list technological <dfn data-lt="capability">capabilities</dfn>:
features, which a web map might include, that could help solve the use cases.
Capabilities are potential requirements for a native HTML web map.
To assess whether the capability should be a requirement, we examine:
</p>
<dl>
<dt>Existing implementations</dt>
<dd>
How common is this capability in the reviewed JS web map frameworks?
Do they implement it with consistent, well-established patterns?
Are there any notable limitations of the current implementations,
when measured against the  <a href="#principles">principles of the inclusive web</a>?
</dd>
<dt>Supported use cases</dt>
<dt>
Which use cases are enabled by this capability?
</dt>
<dt>Uses beyond mapping</dt>
<dd>
Is there a demand for this capability on the web,
beyond its use in web mapping?
</dd>
<dt>Related web specifications</dt>
<dd>
How is this capability related to existing web standards
or proposed specifications?
Can the web map implementation build on existing features?
</dd>
</dl>
<p>
For each capability, we conclude by summarizing its costs and potential benefits
(using tags defined in the next section)
for integration as a native HTML web map feature.
We assign it one of three possible conclusions:
</p>
<dl>
<dt><dfn id="requirement" data-ucr-role="conclusion-dfn" data-ucr-tag-type="good">requirement</dfn></dt>
<dd>
The capability is essential for a native HTML web map implementation.
</dd>
<dt><dfn id="enhancement" data-ucr-role="conclusion-dfn" data-ucr-tag-type="caution">enhancement</dfn></dt>
<dd>
The capability would be nice to have in native HTML web maps,
but isn't necessary for the initial specification.
</dd>
<dt><dfn id="impractical" data-ucr-role="conclusion-dfn" data-ucr-tag-type="bad">impractical</dfn></dt>
<dd>
The capability isn't currently realistic for inclusion in native HTML web maps.
</dd>
</dl>
<p>
If there is not yet enough evidence for a conclusion,
the capability will be marked
<dfn id="undecided" data-ucr-role="conclusion-dfn">undecided</dfn>.
</p>
</section>

<section id="intro-glossary">
<h3>Glossary of key terms</h3>
<p>
Web mapping and geospatial data have a rich vocabulary
that is not always clear to outsiders.
This report uses the following terms in the ways defined here,
unless another meaning is clearly specified:
</p>
<dl>

<dt><dfn>map</dfn></dt>
<dd>
A graphical representation of the features of and spatial relationships between places.
Unless otherwise specified,
maps referred to in this report are assumed to be <a>geographic maps</a>
with a two-dimensional representation.
</dd>

<dt><dfn>geographic map</dfn></dt>
<dd>
A map of part (or all) of the surface of Earth (or another planet),
with a defined mathematical relationship between
positions on the map and geographical positions on the planet.
</dd>

<dt><dfn>non-geographic map</dfn></dt>
<dd>
A map in which positions on the graphic are not defined
relative to positions on the Earth's surface.
</dd>

<dt><dfn>interactive map</dfn></dt>
<dt><dfn>slippy map</dfn></dt>
<dd>
A map rendered as part of an interactive computer application,
such that the user of the app can manipulate aspects of the map display.
In particular, a slippy map is one in which
the user can pan the displayed map to view a different region.
</dd>

<dt><dfn>web map</dfn></dt>
<dd>
An interactive map integrated into a web page.
</dd>

<dt><dfn data-lt="GIS|geographic information system">geographic information system (GIS)</dfn></dt>
<dd>
A database system for managing geographic data (or other spatial data),
often including software for displaying the data as interactive maps.
</dd>

<dt><dfn>map server</dfn></dt>
<dd>
An internet-connected GIS,
that provides processed geographic data or map images
on request from client software (such as web browsers).
Map servers used by web maps are normally built on HTTP,
but many formats are used for search requests and data responses.
Some of these are described by formal standards,
others are defined only by the documentation of a particular map server.
</dd>

<dt><dfn data-lt="OWS|OGC Web Services|Open Geospatial Consortium Web Services">OGC Web Services (OWS)</dfn></dt>
<dd>
A set of <a href="https://www.opengeospatial.org/standards/">standards developed by the Open Geospatial Consortium (OGC)</a>
that define communication protocols between map servers and client software.
OWS standard define a format for exposing the available capabilities of the map server,
and for structuring requests for map data for a certain region,
possibly restricted by other search parameters.
The format of the returned map data is defined separately.
OWS standards include:
<ul>
  <li><dfn data-lt="Web Map Service|WMS">Web Map Service (WMS)</dfn>,
    for accessing a custom processed map image
    that directly represents the requested region and query parameters</li>
  <li><dfn data-lt="Web Map Tile Service|WMTS">Web Map Tile Service (WMTS)</dfn>,
    for accessing pre-processed map <a>tiles</a>,
    which may only represent a <a>layer</a> of the final map</li>
  <li><dfn data-lt="Web Feature Service|WFS">Web Feature Service (WFS)</dfn>,
    for accessing <a>vector feature</a> data</li>
  <li><dfn data-lt="Web Coverage Service|WCS">Web Coverage Service (WCS)</dfn>,
    for accessing raw <a>coverage</a> data</li>
  <li><dfn>OWS Context</dfn>,
    for returning metadata with references to other map services</li>
</ul>
</dd>

<dt><dfn>(map) projection</dfn></dt>
<dd>
A method of converting positions on the surface of a sphere (the Earth)
into positions in a 2D rendering (display screen or paper map).
All map projections involve some distortion of the data,
but different projections are preferred for different use cases.
<em>TODO: Figure comparing common map projections</em>
</dd>

<dt><dfn>coordinates</dfn></dt>
<dt><dfn>coordinate pair</dfn> or <dfn>coordinate triple</dfn></dt>
<dd>
A mathematical description of a particular location,
on a map (<dfn>map coordinates</dfn>)
or in reality (<dfn>geographic coordinates</dfn>).
Coordinates are generally defined as a pair or triple of measurements,
depending on whether the location they defining is in two dimensions
(e.g., a location on the surface of the Earth or position on a map)
or three dimensions.
</dd>

<dt><dfn data-lt="CRS|coordinate reference system">coordinate reference system (CRS)</dfn></dt>
<dd>
A standard way of defining map or geographic coordinates,
so that locations can be precisely compared or aligned
between different maps, map layers, or spatial data sets.
Some CRS are based on geographic coordinates,
while others are based on map coordinates
and therefore incorporate a map projection into their calculation.
</dd>

<dt><dfn>latitude</dfn> and <dfn>longitude</dfn></dt>
<dd>
Coordinate system for describing positions on the surface of the Earth.
Latitude values represent North-South distance from the equator.
Longitude values represent East-West distance from a reference line
(the prime meridian) that connects the poles.
Both values are angles, usually degrees.
Latitude and longitude are used in multiple <a>coordinate reference systems</a>;
the exact CRS needs to be specified to define a location precisely.
<em>TODO: Figure of latitude/longitude</em>
</dd>

<dt><dfn>altitude</dfn></dt>
<dd>
A coordinate that represents the height of a point above or below a reference surface.
A <a>coordinate reference system</a> that uses altitude along with latitude and longitude can define geographic points in 3D space.
Altitude is measured in length units, such as meters or feet.
</dd>

<dt><dfn>feature</dfn></dt>
<dd>
Something of interest on the map.
Conceptually, the map feature includes the location or geographic shape
of this spatial thing, as well as additional information
describing what it is or why it is interesting.
This information may be conveyed on the map with text labels
or with icons, colors, or other cartographic symbols.
</dd>

<dt><dfn data-lt="vector|vector feature">vector feature</dfn></dt>
<dd>
A map feature that has a mathematically defined spatial geometry
based on coordinate data.
Different spatial data structures support different types of vector geometry,
but the basic 2D vector feature types are
<a>point</a>, <a>polyline</a>, and <a>polygon</a>.
<em>TODO: Figure of different types of feature geometries (point, multipoint, polyline, etc.)</em>
</dd>

<dt><dfn>coordinate point</dfn></dt>
<dt><dfn data-lt="point|point feature">point feature</dfn></dt>
<dd>
A spatial location defined by a single set (pair or triple) of coordinates.
A point has no shape or extent,
although in some data formats it may include a level of imprecision or uncertainty.
</dd>

<dt><dfn>polyline</dfn></dt>
<dd>
A vector feature defined as an ordered list of coordinate points,
and the straight lines connecting them.
(Where "straight" is relative to the geometry being described,
and might be across the surface of a sphere.)
</dd>

<dt><dfn>polygon</dfn></dt>
<dd>
A vector feature defined as a two-dimensional shape enclosed by a polyline,
where the last point on the polyline connects back to the first one.
In some data formats, a polygon includes a shape with holes (exclusions) in it,
where the hole is defined by a separate enclosed polyline.
</dd>

<dt><dfn>coverage</dfn></dt>
<dd>
Spatial data that conceptually represents a measurable value that varies across space.
In practice, coverage data is usually encoded as a grid of points
at a specified resolution, with the data value at each point.
This grid of values can often be represented as pixel colors in a <a>raster map layer</a>.
</dd>

<dt><dfn data-lt="layer|map layer">(map) layer</dfn></dt>
<dd>
A subset of the map's graphics which could be rendered independently
from other graphics for the same region.
Multiple map layers can be aligned based on their shared <a>coordinates</a>,
then composited together (drawn one on top of another) to create the final map view.
</dd>

<dt><dfn>base layer</dfn></dt>
<dd>
The map layer that provides the background/bottom layer in the compositing stack.
It is usually fully opaque.
</dd>

<dt><dfn>overlay</dfn></dt>
<dd>
A partially-transparent <a>map layer</a>,
designed to be positioned on top of a <a>base layer</a>.
</dd>

<dt><dfn data-lt="vector map|vector map layer">vector map layer</dfn></dt>
<dd>
A map layer defined using data structures that describe individual <a>vector features</a>
and their coordinates,
which is then used as input instructions to drawing code in the map rendering tool.
Vector formats can preserve the meaning of the different graphical marks on their page,
and allow them to by dynamically styled or altered by the map rendering software.
But, that flexibility requires more processing power in the rendering software,
and may require more data to represent very detailed graphics.
</dd>

<dt><dfn data-lt="raster|raster map|raster layer|raster map layer">raster map layer</dfn></dt>
<dd>
A map layer defined using raster image formats,
which specify the final colors at each position (pixel) in the rendered result.
Raster maps can be generated from vector data,
or they may be created from photographs or drawings.
</dd>

<dt><dfn data-lt="tile|tiled">tile</dfn></dt>
<dd>
A subset of a map layer that represents a particular region of the map,
usually a rectangle in a particular map projection.
Larger regions of the map can be drawn by rendering multiple tiles
side-by-side in a grid.
In a <a>slippy map</a>, tiles can be fetched from a server and rendered as needed
when the user moves the view to different parts of the map.
Tiles can be <a>raster</a> or <a>vector</a>,
although raster tiles are currently more common for web maps.
</dd>

<dt><dfn>tileset</dfn></dt>
<dd>
A set of map tiles which can be used as a map layer.
In simplest tilesets, the map tiles combine as a grid (<dfn>tile matrix</dfn>) to form a single map layer.
More complex tilesets include multiple tile matrices covering the same regions at different scales (zoom levels).
<em>TODO: Create/find figure explaining tileset pyramids.</em>
</dd>

</dl>

</section>

</section>

<section id="principles">
<h2>Guiding Principles</h2>
<p>
The structure of this review is inspired by many other projects
that have outlined best practices for web standards developments.
This section briefly outlines the principles behind our approach,
with links to further reading.
</p>

<section id="extensible-web">
<h3>The extensible web</h3>
<p>
The report uses an evidence-based approach,
defining requirements not based on hypothetical use cases
but on web map tools that are already in use.
We assume that
the common features of existing, widely-used web map frameworks
represent core functionality
that web users and website authors expect from native web maps.
</p>
<p>
This approach is inspired by [[[EXTENSIBLE]]]
which aims to
“tighten the feedback loop between the editors of web standards and web developers,”
establishing “a clear path for good ideas by web developers to become part of the infrastructure of the web”
[[EXTENSIBLE]].
</p>
<p>
Much of the manifesto focuses on making it easier
for developers to experiment with new features —
to expose web platform capabilities at a more granular level,
so that developers can remix and extend them to try out new ideas.
HTML custom elements and CSS custom properties
are just two of many examples of how web standards efforts since 2012
have focused on creating better building blocks for web developers.
</p>
<p>
But the implicit second step of the extensible web approach
is that, once a consensus has developed from real-world experience
with particular features or patterns on the web,
those features can be standardized with confidence.
</p>
<p>
Web maps are extremely complex user interfaces.
If that complexity is to be built-in to web browsers,
the extensible web mindset requires that it be exposed
to developers as individual capabilities that can be remixed and extended.
For that reason,
this review breaks web map functionality
into very low-level capabilities.
In addition to describing how each capability is used in mapping,
we discuss how the same building block could be used for other web content.
Focusing on these low-level capabilities also ensures
that we do not overlook important details,
such as the need to make individual interactions accessible to all users.
</p>
</section>

<section id="priorities">
<h3>Priorities for web standards</h3>

<p>
To decide whether a capability
should or shouldn't be considered a requirement for web maps,
we need to assess its benefits and costs.
But benefits and costs are subjective:
to calculate them, we need a set of values or principles
defining best practices for web standards.
Only then can we assess whether integrating a feature into web browsers
can bring the web closer to our ideals.
</p>
<p>
Benefits and costs are also different from different perspectives.
Integrating web maps into HTML means convincing
other web standard editors and web browser developers.
But once a web standard is adopted,
the number of website authors who use it will (hopefully)
be much larger than the number of people who worked on the initial standard;
the number of people who use those websites will be larger still.
The [[[html-design-principles]]]
rely on these numbers to establish a “priority of constituencies”:
</p>
<blockquote>
In case of conflict, consider users over authors over implementors over specifiers over theoretical purity.
…
Of course, it is preferred to make things better for multiple constituencies at once.
[[html-design-principles]]
</blockquote>
<p>
This section introduces the categories by which we measure
costs and benefits to each of these constituencies.
</p>

<section id="principles-users">
<h4>Users</h4>
<p>
An inclusive web is available to everyone,
to connect and create in the ways most comfortable to them.
</p>
<p>
In this report,
the user-friendliness of a potential web map feature is assessed on these points:
</p>
<dl>
<dt>privacy & security</dt>
<dd>
<p>
Can this feature be implemented in a privacy-respecting manner?
Are there any other security concerns from this feature?
Would making it a built-in feature, standardized in web browsers,
improve privacy & security compared to current web practice?
</p>
<p>
Tags for the costs and benefits of potential requirements:
</p>
<ul>
<li>
<dfn id="privacy-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Privacy: potential improvement</dfn>
indicates that a built-in browser implementation of this feature,
if done correctly,
could improve the protection of the end user's privacy,
compared to current practices on the web.
</li>
<li>
<dfn id="privacy-potential-origin"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Privacy: potential improvement for website origin isolation</dfn>
indicates that a built-in browser implementation of this capability,
if done correctly,
could make it easier for website authors to use web maps
without exposing confidential (user or corporate) data to third parties.
</li>
<li>
<dfn id="security-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Security: potential improvement</dfn>
indicates that a built-in browser implementation of this capability,
if done correctly,
could improve the protection of the security of the browser environment, compared to current practices.
</li>
<li>
<dfn id="privacy-personal-data"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Privacy: involves personal data</dfn>
indicates that in order to fully implement this capability,
the browser would have access to sensitive or personally-identifying data about the user,
which would need to be protected.
</li>
<li>
<dfn id="privacy-fingerprinting"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Privacy: possible fingerprinting</dfn>
indicates that implementing this capability
would expose to website code user settings or data from device sensors,
which could make it easier for website trackers to generate a unique “fingerprint”
for identifying that user across many sites.
</li>
<li>
<dfn id="privacy-sensitive-data-revealed"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Privacy: reveals sensitive data</dfn>
indicates that fully implementing this capability
requires revealing sensitive or personally-identifying data to website code.
</li>
<li>
<dfn id="security-ui"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Security: user interface override</dfn>
indicates that this capability allows website code to alter the normal browser UI
in a way that could be used by a malicious code to mislead users.
</li>
<li>
<dfn id="security-risks"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Security: other risks</dfn>
indicates that this capability includes other aspects
that could make a secure implementation difficult.
</li>
</ul>
<p>
Further information:
</p>
<ul>
<li>
<a href="https://w3ctag.github.io/security-questionnaire/">W3C TAG's Security and Privacy Self-Review Questionnaire</a>
[[security-privacy-questionnaire]]
</li>
<li>
[[GEOLOCATION-PRIVACY]] [[[GEOLOCATION-PRIVACY]]]
</li>
</ul>
</dd>
<dt>accessibility</dt>
<dd>
<p>
Does including this capability in a web map standard
make it easier to ensure an accessible experience
(assuming an accessibility-focused browser implementation)?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="accessibility-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Accessibility: potential improvement</dfn>
indicates that a built-in browser implementation of this feature,
if done correctly,
could improve the accessibility compared to current practices on the web.
</li>
<li>
<dfn id="accessibility-info-needed"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Accessibility: research needed</dfn>
indicates that there is not a clear best practice
for how to implement this capability accessibly.
</li>
<li>
<dfn id="accessibility-author-context"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Accessibility: needs author-provided context</dfn>
indicates that a good browser implementation is not enough
to make this capability fully accessible;
content author would always need to provide extra information
(e.g., alternative text or captions).
</li>
</ul>
<p>Further information:</p>
<ul>
<li>
<a href="https://www.w3.org/TR/WCAG/">Web Content Accessibility Guidelines</a>
[[WCAG21]]
</li>
<li>
<a href="https://www.w3.org/WAI/standards-guidelines/atag/">Authoring Tool Accessibility Guidelines</a>
[[ATAG20]]
</li>
<li>
<a href="https://www.w3.org/WAI/standards-guidelines/uaag/">User Agent Accessibility Guidelines</a>
[[UAAG20]]
</li>
</ul>
</dd>
<dt>internationalization & localization</dt>
<dd>
<p>
Can this feature be implemented in a manner that works for all languages and regions?
Does building it into the browser increase the likelihood that internationalization is done correctly?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="i18n-potential-text"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Internationalization: potential improvement (languages)</dfn>
indicates that a native browser implementation,
if done correctly,
could improve the handling of text in many languages,
compared to current practices in web maps.
</li>
<li>
<dfn id="i18n-potential-geo"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Internationalization: potential improvement (spatial data)</dfn>
indicates that a native browser implementation,
if done correctly,
could improve the ability of web maps (compared to current practices)
to work in many regions with different ways of describing locations and other spatial data.
</li>
<li>
<dfn id="i18n-localized-UI"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Internationalization: UI localization required</dfn>
indicates that a correct implementation of this feature
would need to include translations or other localizations (e.g., different icons or layout).
</li>
<li>
<dfn id="i18n-regional-data"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Internationalization: regional standards</dfn>
indicates that the standard UI patterns or data formats vary by geographic region.
</li>
<li>
<dfn id="i18n-difficult"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Internationalization: difficult to do well</dfn>
indicates that the capability involves other aspects
that are frequent sources of internationalization and localization errors.
</li>
<li>
<dfn id="i18n-unstable"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Internationalization: unstable data</dfn>
indicates that a correct implementation depends
on information that may change over time  ,
and would need to be updated by the browser.
</li>
</ul>
<p>
Further information:
</p>
<ul>
<li>
<a href="https://www.w3.org/International/techniques/developing-specs?collapse">W3C Internationalization checklist</a>
</li>
<li>
<a href="https://w3c.github.io/bp-i18n-specdev/">Internationalization Best Practices for Spec Developers</a>
[[international-specs]]
</li>
</ul>
</dd>
<dt>performance & cost to users<dt>
<dd>
<p>
Would building in this feature significantly reduce the amount of data downloaded to the user device,
or the amount of custom code that needs to run?
Or would it impose heavy computation demands on the user device?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="performance-data-savings"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Performance: data savings</dfn>
indicates that making this a browser feature could reduce data demands on the user's network.
Of course, nearly any built-in capability will create some data savings
compared to downloading JavaScript to achieve the same effect;
this tag is only used when the potential data savings are particularly notable.
</li>
<li>
<dfn id="performance-potential"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Performance: potential optimization</dfn>
indicates that a native browser implementation
could be much more efficient in its computation requirements,
compared to JavaScript tools.
</li>
<li>
<dfn id="performance-high-impact"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Performance: high cost feature</dfn>
indicates that this feature involves high performance costs,
regardless of whether it is defined in browser code or in JavaScript.
</li>
</ul>
<p>
Further information:
</p>
<ul>
<li class="issue">
  Need references regarding performance considerations for spec developers.
</li>
</ul>
</dd>
</dl>
</section>

<section id="principles-authors">
<h4>Authors</h4>
<p>
Website authors include developers who write code
and writers, designers, and other creators of web content.
When discussing web maps, website authors also include
geospatial experts who create map data and want to publish it on the web.
</p>
<p>
For an author that cares about their user,
it of course helps if there are native implementations
of author-focused features like accessibility.
But there are other ways a good web standard can make the author's job easier:
</p>
<dl>
<dt>simplicity & flexibility</dt>
<dd>
<p>
For an author, a good web standard
should make it easy to create common web patterns,
while still making it possible to create unique and customized experiences.
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="author-simplicity"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author experience: simple defaults</dfn>
indicates that the capability would greatly simplify authoring common use cases.
</li>
<li>
<dfn id="author-extensibility"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author experience: extensible</dfn>
indicates that the capability provides an important hook
for extending the basic web map experience.
</li>
<li>
<dfn id="author-custom-design"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author experience: customizable design</dfn>
indicates that the capability is needed
to allow authors to customize the appearance of web maps
to better integrate with their site design
(while still using other web map capabilities).
</li>
</ul>
</dd>
<dt>maintainability & cost to authors</dt>
<dd>
<p>
Do current implementations of the feature rely on third-party services
which may change in ways that could break website content?
Do they involve ongoing costs that could be mitigated by a native version of the feature?
</p>
<p>Related tags:</p>
<ul>
<li>
<dfn id="author-independence"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author maintainability: removes dependencies on third-party services</dfn>
indicates that current implementations cannot be fully self-hosted by the website,
creating a third-party dependency that could be removed with a native HTML capability.
</li>
<li>
<dfn id="author-cost-cutting"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Author maintainability: cost savings</dfn>
indicates that current web map implementations of the feature have ongoing service costs
which could be mitigated by integrating with native platform versions of the feature.
</li>
</ul>
</dd>
<dt>consistency & coordination with the existing web platform</dt>
<dd>
<p>
Can this feature be defined in a way that integrates well with the rest of the web?
Does it reuse API and markup patterns that authors already know?
Can it be added to websites in a way that degrades gracefully in unsupporting web browsers?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="consistency-match"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Consistency: established patterns</dfn>
indicates that this capability can be modelled
after an existing concept or pattern in the web platform.
</li>
<li>
<dfn id="consistency-progressive"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Consistency: progressive enhancement</dfn>
indicates that this capability could be included in websites as an optional enhancement
of existing functionality.
</li>
<li>
<dfn id="consistency-fallbacks"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Consistency: fallbacks possible</dfn>
indicates that this capability could be designed to support degradation
to a fallback state (with corresponding loss of function or extra costs).
</li>
<li>
<dfn id="consistency-with-what"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="caution">Consistency: platform is inconsistent</dfn>
indicates that it will be difficult to make this feature consistent with the web platform,
because existing platform features are inconsistent with each other.
</li>
<li>
<dfn id="consistency-broken"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="bad">Consistency: breaks established patterns</dfn>
indicates that the feature would be clearly inconsistent with other aspects of the web platform.
</li>
</ul>
</dd>
</dl>

<p>
Further information for all authoring & API design considerations:
</p>
<ul>
<li>
[[[html-design-principles]]] [[html-design-principles]]
</li>
<li>
<a href="https://whatwg.org/faq">WHATWG FAQ</a>,
<a href="https://github.com/whatwg/html/blob/master/FAQ.md">HTML Standard FAQ</a>,
and <a href="https://whatwg.org/policies">WHATWG Policies</a>
</li>
<li>
<a href="https://w3ctag.github.io/webcomponents-design-guidelines/">Guidelines for creating web platform compatible components</a>
[[webcomponents-design-guidelines]]
</li>
<li>
[[[API-DESIGN-PRINCIPLES]]] [[API-DESIGN-PRINCIPLES]]
</li>
</ul>
</section>

<section id="priciples-implementers">
<h4>Implementers</h4>
<p>
Implementers, for a web standard,
are the people who build and maintain web browsers and other user agent software.
Because much of the work of a web browser is to work as the user's agent,
features that are good for the user when it comes to security or performance
are also good for implementers.
But some implementer benefits aren't directly exposed to the user:
</p>
<dl>
<dt>ease of implementation</dt>
<dd>
<p>
An implementation that already exists is always easier.
Could this feature reuse code that is already available to the browser?
</p>
<p>
Related tags:
</p>
<ul>
<li>
<dfn id="implementation-incremental"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Implementation: Extends web platform</dfn>
indicates that this capability is an incremental extension of existing web platform features,
and could be designed to reuse a lot of existing code.
</li>
<li>
<dfn id="implementation-native"
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good">Implementation: Exposes native platform</dfn>
indicates that, while this capability is not currently available in the web platform,
it exists in native application frameworks supported by the major operating systems.
A web browser could expose the native feature instead of re-implementing it from scratch.
</li>
</ul>
</dd>
</dl>
</section>

</section>
</section>

<section id="use-cases">
<h2>Use Cases</h2>
<p>
The basic use cases for website authors focus on presenting information.
Different types of map data require different display capabilities.
More advanced geographic application development

End users may wish to use that information
in ways that go beyond what the website author intended;
those use cases are grouped separately.
</p>

<section id="content-author-use-cases">
<h3>Content author use cases</h3>

<section id="use-case-create-map" data-ucr-role="use-case">
<h4>Display an interactive map within a web page</h4>
<p>
Before discussing any extra capabilities,
there must be some way to define a map viewer in a web page,
either from markup or from script.
</p>
<p>
Maps on the web are used to give directions,
to display data,
to tell stories,
and to teach geography,
among many other uses.
Of course, most use cases require additional capabilities
— this is just the foundation!
</p>
<figure>
  <img src="images/examples/create-map_google-maps.jpg" width="450" height="336" alt="Google Maps example: Create a basic map.">
  <figcaption>Google Maps example implementation of "Display an interactive map within a web page".</figcaption>
</figure>
<p>
See <a href="examples/create-map.html" target="examples">examples of creating a basic map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="77">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-declarative-map"></a>
  or <a href="#capability-create-initialise-and-display-a-map"></a></li>
</ul>
</section>

<section id="use-case-single-location" data-ucr-role="use-case">
<h4>Display a map centered on a point location</h4>
<p>
For a website creator, this is the simplest web map use case:
display a map from a location description.
Usually, the map layer is at a zoom level that shows streets and points of interest,
with a pinpoint marker showing the specific location.
</p>
<p>
This type of web map is used
by websites for stores, restaurants, and countless other organizations with physical locations.
It is also used by news media to display the location described in an article.
In social media and blogs,
a single-location map can be used to show where a post was uploaded from,
or where a photograph or video was taken.
</p>
<figure>
  <img src="images/examples/single-location_tomtom-sdk-web-vector-maps.jpg" width="450" height="336" alt="TomTom Maps SDK for Web example: Single-location map viewer.">
  <figcaption>TomTom Maps SDK for Web example implementation of "Display a map centered on a point location".</figcaption>
</figure>
<p>
See <a href="examples/single-location.html" target="examples">examples of single-location map viewers</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="33">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-default-map"></a>
  or <a href="#capability-custom-map-tiles"></a></li>
<li><a href="#capability-location-latlong"></a>
  or <a href="#capability-location-address"></a></li>

<li><a href="#capability-marker-points"></a>
  or <a href="#capability-add-marker-or-multiple-markers-map"></a></li>
</ul>
</section>

<section id="use-case-static-map" data-ucr-role="use-case">
<h4>Display a region of map data as a static image</h4>
<p>
Although this review mainly focuses on interactive map viewers,
authors sometimes want a map displayed as a static image, without pan/zoom capabilities.
This is common in cases where the accompanying text
refers to specific features in the map,
or when a series of maps will be contrasted.
</p>
<p>
See <a href="examples/static-map.html" target="examples">examples of static map displays</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="17">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-no-js"></a></li>
</ul>
</section>

<section id="use-case-multiple-location-markers" data-ucr-role="use-case">
<h4>Display multiple point locations as map markers</h4>
<p>
The most common use case for a web map is to show
one or more locations of a business or organization.
Maps that display pinpoint locations can also be used for data visualization,
demonstrating spatial patterns of particular events or occurrences.
Other examples of point markers on a map include
search results (e.g., restaurants),
traffic information (e.g., locations of construction roadworks),
or the locations where photographs in a gallery were taken.
</p>
<p>
For many use cases,
the website author will want to choose the icon used to mark the location,
with different markers for different types of point features.
</p>
<figure>
  <img src="images/examples/multiple-location-markers_bing-maps-control-api.jpg" width="450" height="336" alt="Bing Maps Control API example: Display multiple point locations as map markers.">
  <figcaption>Bing Maps Control API example implementation of "Display multiple point locations as map markers".</figcaption>
</figure>
<p>
See <a href="examples/multiple-location-markers.html" target="examples">examples of displaying multiple point locations as map markers</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="78">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Everything listed in <a href="#use-case-single-location"></a></li>
<li><a href="#capability-marker-points"></a></li>
</ul>
</section>

<section id="use-case-poly-features" data-ucr-role="use-case">
<h4>Display routes/paths or regions</h4>
<p>
Lines and curves (<a>polyline</a> features) drawn on a map represent
roads, rivers, directions between places,
or the observed path of a moving object.
Shapes (<a>polygon</a> features) are used for political regions (country and municipal boundaries),
building footprint outlines,
and for contour lines which mark the extent of a certain value within continuous data
(e.g., elevation).
Polygons are also used for roads, rivers and so on at higher zoom levels,
where the true shape of the feature can no longer be approximated as a single line.
</p>
<p>
See <a href="examples/poly-features.html" target="examples">examples of displaying routes and regions</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="36">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Everything listed in <a href="#use-case-single-location"></a></li>
<li><a href="#capability-vector-features"></a></li>
</ul>
</section>

<section id="use-case-html-annotations" data-ucr-role="use-case">
<h4>Display custom web content describing map features</h4>
<p>
Map features often need additional content attached to them
in order to provide context for the viewer.
For example, with the most common mapping use case of displaying the various locations of an organization,
additional content can display a location's opening hours or street address.
</p>
<p>
This use case is especially important for data visualization;
a map can serve as a visual interface that allows a user to navigate map features
and only show the information that they are interested in.
</p>
<p>
See <a href="examples/html-annotations.html" target="examples">examples of displaying custom HTML annotations</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="37">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Everything listed in <a href="#use-case-single-location"></a></li>
<li><a href="#capability-hyperlinks"></a></li>
</ul>
</section>

<section id="use-case-custom-map" data-ucr-role="use-case">
<h4>Display custom imagery as a map layer</h4>
<p>
Many mapping applications require custom imagery
that goes beyond annotations of an existing map.
</p>
<p>
Unlike map <a>features</a>, which can be defined in geometric terms,
map <a>coverages</a> define continuous variations,
and are usually represented as <a>raster</a> image data.
Many maps of natural features involve coverage data,
such as maps showing terrain, vegetation cover, rainfall, or elevation.
Raster image layers are also used for aerial and satellite photographs,
and for pre-rendering vector feature data, on the server or in a specialized application.
Custom map layers — in contrast to maps from major web map services —
are necessary if displaying confidential business data,
new research data,
maps of proposed developments or historical geography,
maps of non-Earth bodies such as Mars and the Moon,
or any other type of map not included in the major wayfinding street maps.
</p>
<p>
When the custom map layer is of a limited scope,
it can often be represented as a single image file.
Single images are practical for <a href="#use-case-static-map">static map views</a>,
and other cases where a broader spatial context is not as important,
or when the author is trying to make a specific point about a set of data.
Single image layers may also be rendered on the fly from a <a>WMS</a>.
</p>
<p>
To support slippy web maps with extensive pan and zoom capabilities, however,
the custom images need to be divided into tilesets
and the map viewer needs to be able to dynamically fetch the correct images.
</p>
<figure>
  <img src="images/examples/custom-map_mapbox-gl.jpg" width="450" height="336" alt="MapBox GL example: Display custom imagery as a map layer.">
  <figcaption>MapBox GL example implementation of "Display custom imagery as a map layer".</figcaption>
</figure>
<p>
See <a href="examples/custom-map.html" target="examples">examples of specifying a data source for a map tile layer</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="38">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-single-custom-image"></a> or <a href="#capability-custom-map-tiles"></a></li>
<li>For more complex maps, <a href="#capability-lazy-load"></a> and <a href="#capability-zoom-swap"></a></li>
<li>For adding custom maps from script, <a href="#capability-define-data-source-tile-layer"></a></li>
</ul>
</section>

<section id="use-case-layers" data-ucr-role="use-case">
<h4>Combine multiple layers of map tile data or features</h4>
<p>
This is one of the fundamental use cases of web mapping.
Because creating a complete tileset is such a large endeavor,
almost all web maps use a pre-existing set of tiles from a provider,
in combination with any number of layers
consisting of data or features created by the map author.
</p>
<p>
See <a href="examples/layers.html" target="examples">examples of multi-layer maps</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="11">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-single-custom-image"></a> or <a href="#capability-custom-map-tiles"></a></li>
<li>For adding custom maps from script, <a href="#capability-define-data-source-tile-layer"></a></li>
</ul>
</section>

<section id="use-case-alternative-layers" data-ucr-role="use-case">
<h4>Provide alternative map layers which the user can select</h4>
<p>
Different users may be interested in different aspects of a map (e.g., roads vs terrain),
or may prefer different styles (e.g., light vs dark).
When alternative maps are available,
the website author needs a way to display the options to the end user,
and easily swap them on the user's request.
</p>
<p>
Note: the ability to re-style the default map interface is also listed
<a href="#use-case-color-scheme">as a web-visitor use case</a>.
But alternative map layers are part of the content, as well.
</p>
<figure>
  <img src="images/examples/alternative-layers_apple-maps-mapkit-js-api.jpg" width="450" height="336" alt="MapKit JS (Apple Maps) API example: Provide alternative map layers which the user can select.">
  <figcaption>MapKit JS (Apple Maps) API example implementation of "Provide alternative map layers which the user can select".</figcaption>
</figure>
<p>
See <a href="examples/alternative-layers.html" target="examples">examples of allowing the user to select a different style for a map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="81">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>(declarative) or <a href="#capability-specify-style-map"></a> (API)</li>
<li><a href="#capability-determine-current-style-map"></a></li>
</ul>
</section>

<section id="use-case-technical-drawings" data-ucr-role="use-case">
<h4>Display drawings or schematics without geographic coordinates</h4>
<p>
Many of the capabilities of a map viewer widget —
panning and zooming, possibly with synchronized layers
or dynamically loaded content for different positions or zoom layers —
are useful for non-map content,
or for maps that don't have geographic coordinates.
Examples include technical schematics, blueprints,
data charts,
“mind maps” and other flow charts,
or maps of fictional places.
An author who is familiar with map widgets
would want to reuse the same technology
for displaying these types of map-like content.
</p>
<figure>
  <img src="images/examples/technical-drawings_leafletjs-openstreetmap-tiles.jpg" width="450" height="336" alt="Leaflet.js (with OpenStreetMap tiles) example: Non-geographic content in map viewers.">
  <figcaption>Leaflet.js (with OpenStreetMap tiles) example implementation of "Display drawings or schematics without geographic coordinates".</figcaption>
</figure>
<p>
See <a href="examples/technical-drawings.html" target="examples">examples of non-geographic content in map viewers</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="1">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-single-custom-image"></a></li>
</ul>
</section>

<section id="use-case-animated-spatial-data-in-layers" data-ucr-role="use-case">
<h4>Include animated spatial data in a layer</h4>
<p>

</p>
<p class="issue discussion" data-number="182">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-require-interaction" data-ucr-role="use-case">
<h4>Require interaction before allowing pan/zoom (or opt-out of such potentially default behavior)</h4>
<p>
When a user hovers their mouse pointer – even if just briefly – over an in-page map viewer
before wanting to continue scrolling the page (or panning the screen display on touch devices),
map viewers are often panned or zoomed instead,
as a result; the user is trapped from scrolling the web page as intended until moving the cursor (or finger)
outside of the map viewer.
</p>
<figure>
  <img src="images/examples/require-interaction-to-pan-zoom_google-maps.jpg" width="450" height="336" alt="Google Maps example: Require interaction before allowing pan/zoom.">
  <figcaption>Google Maps example implementation of "Require interaction before allowing pan/zoom".</figcaption>
</figure>
<p class="issue discussion" data-number="180">
Discuss this section on GitHub.
</p>
</section>

</section>

<section id="visitor-use-cases">
<h3>Website visitor use cases</h3>

<section id="use-case-interactive" data-ucr-role="use-case">
<h4>Reposition or scale a map to find more context for the displayed locations</h4>
<p>
Users often want more information than is initially visible in a map viewer.
The user may zoom out or pan, to help place the displayed location in a larger context.
Or they may zoom in, to see details more clearly.
</p>
<p>
This use case exists regardless of how the user interacts with their device.
For it to be fully supported, the map viewer must be explorable
with all of the following input methods:
</p>
<ul>
<li>mouse/trackpad pointer (with or without a scroll wheel)</li>
<li>touchscreen gestures</li>
<li>standard/intuitive keyboard shortcuts</li>
<li>accessibility API events (e.g., as triggered by a screen reader or voice control software)</li>
</ul>
<p>
Test out panning and zooming on the <a href="examples/single-location.html" target="examples">basic single-location map views</a>
for the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="39">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-pan-map-or-re-centre-map"></a></li>
<li><a href="#capability-zoom-map-in-or-out"></a></li>
</ul>
</section>

<section id="use-case-reset-map-view" data-ucr-role="use-case">
<h4>Reset the map to the initial view</h4>
<p>
It is common for a map viewer to be provided in a web page to show an area relevant to the subject of the page.
An encyclopedia might include a map on its page about a battlefield;
a city guide might include a map on its page about the central railway station.
</p>
<p>
When a user interacts with the map,
they may end up viewing a location far from the starting point,
or with the map at a zoom level which is inconvenient for relating the map view
to the primary content of the page.
</p>
<p>
In such a case it would be useful to provide a mechanism
by which the user can reset the map to the original configuration provided
by the web page author.
</p>
<p>
See <a href="examples/reset-map-view.html" target="examples">examples of allowing a user to reset the map to their starting point</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="83">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>As a custom application feature:
  <ul>
  <li><a href="#capability-pan-map-or-re-centre-map"></a></li>
  <li><a href="#capability-zoom-map-in-or-out"></a></li>
  </ul>
</li>
</ul>
</section>

<section id="use-case-rotate-map" data-ucr-role="use-case">
<h4>Rotate a map, or reset the bearing</h4>
<p>
When following directions on a map,
many people find it easier if the map is oriented to the direction they are facing in real life.
But rotating a map (intentionally or accidentally),
can confuse orientation, too,
so it is also useful to have an easy way to reset the map bearing (rotation)
to the standard view:
with the cardinal directions (North-South and East-West)
aligned screen dimensions (top-bottom and left-right).
</p>
<p>
Test out map rotation on the <a href="examples/single-location.html" target="examples">basic single-location map views</a>
for the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="114">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-change-bearing-map"></a></li>
</ul>
</section>

<section id="use-case-identify" data-ucr-role="use-case">
<h4>Access additional information about a point on the map</h4>
<p>
A map view can't show everything all at once.
Users often want to find more information about the representations on the map.
This information could be presented as details displayed on demand
in a pop-up box or sidebar.
</p>
<p>
The details that are available might include the coordinates of the point,
labels for any features at that point,
metadata or links to further information about the features,
or
local data values for continuous coverage data layers.
</p>
<p>
Some of this information might require querying the server with the selected coordinates.
But to the extent that the information is already available in the map viewer,
it should be accessible by users without the author adding extra features.
</p>
<p class="issue discussion" data-number="21">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-hide-layers" data-ucr-role="use-case">
<h4>Show/hide map layers or feature sets</h4>
<p>
A multi-layered map can be overwhelming.
Users sometimes want to remove overlays or features that aren't relevant to them.
In addition, comparisons between two maps (e.g., for before and after effects) can often be seen more clearly
by toggling between two states within the same display.
</p>
<p>
See
<a href="examples/show-and-hide-features-overlays.html" target="examples">examples of allowing a user to show and hide overlays and features</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="115">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>Declarative / default behavior:
  <a href=""></a>
</li>
<li>As a custom application feature:
  <ul>
    <li><a href="#capability-add-layer-map"></a></li>
    <li><a href="#capability-remove-layer-map"></a></li>
    <li><a href="#capability-display-layer-map"></a></li>
    <li><a href="#capability-hide-layer-map"></a></li>
  </ul>
</li>
</ul>
</section>

<section id="use-case-bookmark" data-ucr-role="use-case">
<h4>Bookmark a location</h4>
<p>

</p>
<p class="issue discussion" data-number="41">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-search-features" data-ucr-role="use-case">
<h4>Search or sort within a set of geographic features</h4>
<p>

</p>
<p class="issue discussion" data-number="42">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-color-scheme" data-ucr-role="use-case">
<h4>Customize the color scheme (light/dark or high contrast)</h4>
<p>

</p>
<p class="issue discussion" data-number="43">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-view-location-securely" data-ucr-role="use-case">
<h4>View the current location on a map, without disclosing to the website</h4>
<p>

</p>
<p class="issue discussion" data-number="75">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-fullscreen" data-ucr-role="use-case">
<h4>View a map in fullscreen mode</h4>
<p>
To get a better view of a map, and to ease navigation,
a user may want to view the map in <a data-cite="fullscreen" data-no-xref="">fullscreen</a> mode.
</p>
<p class="issue discussion" data-number="109">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-picture-in-picture" data-ucr-role="use-case">
<h4>View a map as a Picture-In-Picture media object</h4>
<p>
Displaying a map viewer as a <a data-cite="picture-in-picture" data-no-xref="">Picture-In-Picture</a> (PIP)
media object allows for users to navigate to other applications,
or a different tab in the browser from which the map viewer is embedded,
while still being able to see and interact with the map viewer.
</p>
<figure>
  <img src="images/examples/picture-in-picture_google-maps.jpg" width="450" height="336" alt="Google Maps example: View a map as a Picture-In-Picture media object.">
  <figcaption>Theoretical Google Maps example implementation of "View a map as a Picture-In-Picture media object".</figcaption>
</figure>
<p class="issue discussion" data-number="107">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-augmented-reality" data-ucr-role="use-case">
<h4>View a map in augmented reality</h4>
<p>

</p>
<p class="issue discussion" data-number="135">
Discuss this section on GitHub.
</p>
</section>

<section id="use-case-offline-maps" data-ucr-role="use-case">
<h4>Save map content for offline use</h4>
<p>

</p>
<p class="issue discussion" data-number="123">
Discuss this section on GitHub.
</p>
</section>

</section>

<section id="application-use-cases">
<h3>Application developer use cases</h3>
<p>
Built-in mapping widgets cannot cover all possible mapping applications.
Web application developers need to be able extend and manipulate the viewer,
or respond to user interaction with it.
</p>
<p>
Of course, a script-based mapping application will also usually need
scripted control over basic map configuration.
The necessary capabilities are listed above,
under the relevant <a href="#content-author-use-cases">content author use cases</a>.
A web application author may also wish to implement capabilities
for the benefit of the website visitor;
again, the required capabilities are included in the <a href="#visitor-use-cases">visitor use cases</a>.
</p>


<section id="use-case-add-custom-control" data-ucr-role="use-case">
<h4>Add a custom control to a map</h4>
<p>
A control is a user interface component that is integrated
with a map.
It may provide user feedback about the current state of the
map, provide one or more affordances for manipulating the
state of the map, or some combination of the two.
Typically, controls are integrated into the map display in
such a way that no other map content can overlie or obscure
them.
</p>
<p>
Many client APIs allow developers to implement custom
controls and add them to a map.
The advantage of using a custom control is that it becomes a
peer of the native controls provided by the map, and thus
acquires any inherent capabilities and behaviours of those
controls.
For example, if a map provided a way for the user to hide
all controls, the custom control would be hidden along with
the native controls.
This close integration cannot be achieved by a component
which is external to the map, and only made to appear as if
visually integrated through positioning, without additional
work; furthermore, the integration may not be reliable in
the long term if it must be achieved by relying on
undocumented or underspecified behaviour of the map API.
</p>
<p>
A web developer may wish to add one or more custom controls
to a map so as to provide capabilities that are not
available within the standard set of controls provided by
the mapping API, or to make up for perceived deficiencies of
the provided controls.
</p>
<p>
For example, a default zoom control may be inaccessible to
keyboard users, in which case it could be replaced with an
accessible version that utilised a public API to effect
zooming in response to the keyboard.
</p>
<figure>
  <img src="images/examples/add-custom-control_openlayers-openstreetmap-tiles.jpg" width="450" height="336" alt="OpenLayers (with OpenStreetMap tiles) example: Add a custom control to a map.">
  <figcaption>OpenLayers (with OpenStreetMap tiles) example implementation of "Add a custom control to a map".</figcaption>
</figure>
<p>
See <a href="examples/add-custom-control.html" target="examples">examples of adding a custom control to a map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="79">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-implement-a-custom-control"></a></li>
<li><a href="#capability-add-control-map"></a></li>
<li><a href="#capability-remove-control-map"></a></li>
</ul>
</section>

<section id="use-case-view-change-events" data-ucr-role="use-case">
<h4>Provide feedback to a user as they manipulate the map</h4>
<p>
A web developer may wish to respond to changes such as
position and zoom level of a map as it is manipulated by the
user, in order to update user interface components
containing information related to the map.
</p>
<p>
For example, an application displaying a list of places of
interest in a city might update the list to highlight those
places that are within the current extent of the map as the
user pans and zooms, or filter the list to only show those
items.
On a device where the user's current location is known, the
distance to the currently-displayed centre of the map, along
with an indication of the user's bearing relative to that
point, could be shown.
If an application is showing a list of items whose
associated locations are represented on the map by markers,
selecting a marker could highlight the corresponding list
item.
</p>
<p>
See <a href="examples/view-change-events.html" target="examples">examples of providing feedback to a user as they manipulate the map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="80">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-get-bounds-map"></a></li>
<li><a href="#capability-subscribe-map-move-events"></a></li>
<li><a href="#capability-subscribe-map-zoom-events"></a></li>
<li><a href="#capability-subscribe-marker-selection-events"></a></li>
</ul>
</section>

<section id="use-case-set-view-zoom" data-ucr-role="use-case">
<h4>Move a map to a new position and/or zoom level</h4>
<p>
Complex mapping applications often need to control the displayed map view,
independently of the regular <a href="#use-case-interactive">user-controlled panning and zooming</a>.
The developer's code must be able to move a
map to a new position and/or zoom level.
</p>
<p>
For example, the user may be choosing from a list of
locations of interest, and expect the map to adjust to show
the current point of interest at the centre.
If the items among which the user is choosing are not points
but areas, such as administrative regions, then the map may
need not only to move but also to adjust its zoom level to
one which best fits the area.
</p>
<p>
See <a href="examples/set-view-zoom.html" target="examples">examples of moving a map to a new position and zoom level</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="116">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-zoom-map-in-or-out"></a></li>
<li><a href="#capability-move-the-map-to-display-a-given-location"></a></li>
<li><a href="#capability-pan-and-zoom-to-bounding-box"></a></li>
</ul>
</section>

<section id="use-case-animate-view-change" data-ucr-role="use-case">
<h4>Animate a map through a sequence of points</h4>
<p>
A web developer implementing the display of a number of
locations arranged sequentially may require the ability to
cause the map to animate through the locations by panning
and zooming.
</p>
<p>
Examples include traversing through the points that make up
a set of directions, or through a set of locations that form
part of a temporal sequence.
</p>
<p>
See <a href="examples/animate-view-change.html" target="examples">examples of animating a map through a sequence of points</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="117">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-animate-the-zooming-of-the-map"></a></li>
<li><a href="#capability-animate-the-re-centering-of-the-map"></a></li>
</ul>
</section>

<section id="use-case-change-bearing-map" data-ucr-role="use-case">
<h4>Change the bearing of a map</h4>
<p>
In addition to <a href="#use-case-rotate-map">user-controlled map rotation</a>,
a developer may need to dynamically update the bearing of a map
— that is, to rotate the map view
so that a direction other than North is at the "top".
</p>
<p>
Examples include responding to the orientation of a device,
traversing a route,
and allowing the user to orient themselves with respect to the map
by manipulating it with respect to local landmarks.
</p>
<p>
See <a href="examples/change-bearing-map.html" target="examples">examples of changing the bearing of a map</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="84">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-change-bearing-map"></a></li>
<li><a href="#capability-reset-bearing-map"></a></li>
</ul>
</section>

<section id="use-case-set-layer-visibility" data-ucr-role="use-case">
<h4>Control which layers are currently visible & which can be hidden by the user</h4>
<figure>
  <img src="images/examples/set-layer-visibility_leafletjs-openstreetmap-tiles.jpg?v=2" width="450" height="336" alt="Leaflet.js (with OpenStreetMap tiles) example: Control which layers are currently visible & which can be hidden by the user.">
  <figcaption>Leaflet.js (with OpenStreetMap tiles) example implementation of "Control which layers are currently visible & which can be hidden by the user".</figcaption>
</figure>
<p>
See <a href="examples/set-layer-visibility.html" target="examples">examples of allowing the user to control the layer displayed by a map</a>
as implemented by the reference JavaScript tools.
</p>

<p class="issue discussion" data-number="82">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li>…</li>
</ul>
</section>

<section id="use-case-generate-vector-features" data-ucr-role="use-case">
<h4>Generate new vector features from data</h4>
<p>
Many forms of geographical data are available in vector
formats, such as shapefiles describing the boundaries of
administrative areas and poly lines representing a route.
A web developer wishing to display such external data
requires an API allowing it to be added as an overlay to the
map view.
</p>
<p>
<a href="#use-case-poly-features">Display routes/paths or regions</a>
covers the use of existing vector data, in standard geographic file formats.
However, a web app developer may want to dynamically generate vector shapes from data.
For example, to implement a feature allowing users to draw new shapes on the map,
the developer needs to convert the selected points into a new polygon feature.
</p>
<p>
See <a href="examples/generate-vector-features.html" target="examples">examples of showing a vector data overlay</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="118">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-add-layer-map"></a></li>
<li><a href="#capability-create-an-overlay-defined-by-vector-data"></a></li>
</ul>
</section>

<section id="use-case-heatmap" data-ucr-role="use-case">
<h4>Generate a heatmap overlay from point intensity data</h4>
<p>
Heatmaps are a common way of showing the variation of some
variable across a geographical area,
as the accumulation of intensity created by many point measurements.
</p>
<p>
From the point of view of the end user,
it is a type of <a>coverage</a> data that is displayed as an overlay on a map.
However, many mapping frameworks have specialized APIs
that can generate heatmap layers directly from the point data,
without needing to pre-process it into a <a>raster layer</a>.
</p>
<p>
See <a href="examples/heatmap.html" target="examples">examples of data heatmaps</a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="119">
Discuss this section on GitHub.
</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href="#capability-display-layer-map"></a></li>
<li><a href="#capability-create-an-overlay-defined-by-heatmap-data"></a></li>
</ul>
</section>

<section id="use-case-drag-and-drop" data-ucr-role="use-case">
<h4>Enable drag & drop for map layers</h4>
<p>

</p>
<p class="issue discussion" data-number="106">
Discuss this section on GitHub.
</p>
</section>

</section>

</section>

<section id="js-examples">
<h2>Reviewed JavaScript Tools</h2>
<p>
Numerous options currently exist for a website author
who wants to include a map viewer in a web page,
with a minimum of custom code.
The examples reviewed in this section are used to identify the common features
(and limitations)
of web map viewers.
</p>
<p>
Many major commercial providers of web map data tiles
provide ready-to-use map viewer widgets for websites to use.
In addition, multiple open source JavaScript libraries
have developed to make it easier for website authors to build on other map data services.
</p>
<p class="issue" data-number="25">
Need data to back up the reference implementations.
</p>
<p>
The reviewed implementations come in three forms:
</p>
<ul>
<li>
Embeds that are included in a web page as an <code>iframe</code>;
configuration options are set through the URL in <code>src</code> attribute.
</li>
<li>
JavaScript frameworks that dynamically generate the widget within the current HTML document;
configuration options are passed in as JS function parameters when initializing the map.
</li>
<li>
HTML custom elements,
with configuration through attributes and child elements.
<p class="issue" data-number="23">
Need to decide on web component examples to use as reference.
</p>
</li>
</ul>
<p>
With these different structures, comparisons are not always exact.
Similar functionality may be generated from very different APIs.
We assess first whether a given capability is present in each implementation,
and second whether there are common patterns in how that capability is exposed.
</p>
<p>
For each capability (potential web map feature) that we review,
we assign one of the following implementation levels
to each of the reference tools:
</p>
<dl>
<dt><dfn>full support</dfn></dt>
<dd>
The capability is implemented in a correct and comprehensive manner.
</dd>
<dt><dfn>supported, with limitations</dfn></dt>
<dd>
The feature is implemented,
but there are notable limitations when assessing the implementation
against our <a href="#priorities">priorities</a>.
</dd>
<dt><dfn>partial support</dfn></dt>
<dd>
Some parts of the feature are implemented.
</dd>
<dt><dfn>no support</dfn></dt>
<dd>
The capability could theoretically exist in the tool, but isn't included.
</dd>
<dt><dfn>not applicable</dfn></dt>
<dd>
The capability doesn't make sense for this tool, because of other aspects of its design.
</dd>
</dl>

<p class="note">
Compiling and serving map data is a complex, expensive enterprise.
Many of the map data and search services
require registered developer accounts, with usage-based pricing.
This review focuses on features that are free-to-use for website creators,
at least for low-traffic websites,
or that use data which is available from many interchangeable sources.
However, because of the complexities of pricing models used by some services,
we don't strictly exclude paid features from our assessment of support.
</p>

<section id="google-maps">
<h3>Google Maps embeds and Google Maps Platform API</h3>
<p>
<!-- Not sure what the convention is for formatting footnotes in this report, but perhaps this would be a good source?  https://trends.builtwith.com/mapping/maps/traffic/Entire-Internet. Google Maps holds a 89% market share.-->
By far the most frequently used map widget on the web,<sup>[citation needed]</sup>
Google Maps established many of the de facto standards in how a web map works.
</p>
<p>
Customized iframe embed URLs can be generated from the maps website
(search/customize the view and then select "share"),
or by constructing the URL query string yourself
(a developer API key and account is required).
</p>
<p>
The Google Maps Platform includes a JavaScript API
for generating map viewers and adding custom features and data layers.
It also includes methods to access more complex search functions, local images, and other data.
Most features require an API key and is billed by usage (page views or API requests).
</p>
<p class="issue discussion" data-number="9">
Discuss this section on GitHub.
</p>
</section>

<section id="openstreetmap">
<h3>OpenStreetMap embeds</h3>
<p>
<a href="https://www.openstreetmap.org/">OpenStreetMap</a> is a project to compile free-to-use wayfinding maps of the entire Earth,
from crowdsourced contributions.
</p>
<p>
The interactive map on the group's website can be used to generate embeddable map widgets.
Various options can also be specified
<a href="https://wiki.openstreetmap.org/wiki/Browsing#Other_URL_tricks">in the URL</a> for the embed source.
</p>
<p>
The image tiles created by the project can also be accessed directly by URL recipes,
and these are used in other map viewer widgets and APIs.
The raw data is also re-processed and used by other map data services.
</p>
<p class="issue discussion" data-number="26">
Discuss this section on GitHub.
</p>
</section>

<section id="bing-maps">
<h3>Bing Maps embeds and Bing Maps Control API</h3>
<p>
<a href="https://www.bing.com/maps#">Bing maps</a> provides embeds that can be generated from their website.
For more complex options, the <a href="https://www.microsoft.com/en-us/maps/v8-control">API</a>
can be used to generate widgets with minimal configuration,
but also provides client-side APIs for manipulating the map,
as well as an interface to Bing's search services.
API tokens are required; free and paid plans are available, with usage caps.
</p>
<p class="issue discussion" data-number="27">
Discuss this section on GitHub.
</p>
</section>

<section id="mapkit-js">
<h3>MapKit JS (Apple Maps) API</h3>
<p>
<a href="https://developer.apple.com/maps/web/">MapKit JS</a> provides
a JS framework for integrating Apple Maps in a website,
with a client-side API for customizing interactions,
and integrations with Apple search services.
</p>
<p>
A developer account is required,
along with a method of generating encrypted API tokens on demand on the webserver.
</p>
<p class="issue discussion" data-number="28">
Discuss this section on GitHub.
</p>
</section>

<section id="mapbox">
<h3>Mapbox GL JS API and Mapbox Studio embeds</h3>
<p>
<a href="https://docs.mapbox.com/">Mapbox</a> provides
map data as a service, as well as frameworks for multiple platforms.
The GL JS framework generates map viewer widgets from client-side JavaScript calls,
using WebGL for the actual rendering.
Alternatively, the Mapbox <a href="https://docs.mapbox.com/api/maps/#request-embeddable-html">Maps API</a>
returns complete HTML slippy maps based on URL configuration,
and so can be used as an iframe source. These maps can be configured through <a href="https://www.mapbox.com/mapbox-studio/">Mapbox Studio</a>, a graphical interface for building and styling maps. Each custom map is then assigned an ID, which can be passed into to the slippy map URL in order to fetch the map.
</p>
<p>
An API key is required, with cost based on usage.
</p>
<p class="issue discussion" data-number="12">
Discuss this section on GitHub.
</p>
</section>

<section id="leaflet-js">
<h3>Leaflet.js API</h3>
<p>
<a href="https://leafletjs.com/">Leaflet</a> is a popular open-source JavaScript framework
for building customized map views.
It doesn't currently have a declarative API,
but widgets similar to map embeds can be generated with a few calls to the library methods.
</p>
<p>
Leaflet isn't associated with any particular map data source.
It can use image tiles from most web map (tile) services.
</p>
<p class="issue discussion" data-number="29">
Discuss this section on GitHub.
</p>
</section>

<section id="openlayers">
<h3>OpenLayers API</h3>
<p>
OpenLayers is one of the most established open-source libraries
for creating dynamic web maps from map data in standard formats.
As with Leaflet, it isn't associated with any particular map service.
A basic slippy map can be created with a few lines of custom JavaScript.
</p>
<p class="issue discussion" data-number="30">
Discuss this section on GitHub.
</p>
</section>

<section id="tomtom">
<h3>TomTom Maps SDK for Web</h3>
<p>
TomTom is a provider of geographic search and routing services
and street map imagery.
They provide software development kits (SDK) for mobile and web use,
although their map tile and image APIs can also be used
with other web map frameworks or <a>GIS</a> viewers.
The viewer used by the web SDK is a customized wrapper around <a href="#leaflet-js">Leaflet</a>.
</p>
<p>
TomTom's street map imagery is available as raster tiles,
custom-generated raster images for specified bounds,
or as vector tiles (using Mapbox's vector tile specification).
The example pages use the vector data source.
</p>
<p>
Access to TomTom's map data and search APIs requires an account and API key;
there is a daily quota of free transactions.
</p>
<p class="issue discussion" data-number="49">
Discuss this section on GitHub.
</p>
</section>

<section id="d3-geo">
<h3>D3 Geographies APIs</h3>
<p>
The data visualization library D3 includes the <a href="https://github.com/d3/d3-geo">d3-geo module</a>
which defines methods for manipulating vector map data
(which the website author must provide).
Unlike the other JS tools being reviewed here,
D3 does not include code for a ready-made map viewer widget,
but it is used for custom client-side mapping applications.
</p>
<p class="issue discussion" data-number="13">
Discuss this section on GitHub.
</p>
</section>
</section>

<section id="map-viewers">
<h2>Map Viewer Widget Capabilities</h2>
<p>
The map viewer widget is the interactive component that displays a map to end users.
The map might be the primary purpose of a website,
or a small embedded element in a larger HTML page.
</p>
<p>
For this section of the review,
we focus only on aspects of the map viewer
that are generated by the map widget framework
based on initial configuration and data by the website developers.
In other words,
these are the features that could be represented by elements and attributes
in a native HTML solution.
The next section, <a href="#client-apis">on client-side APIs</a>,
covers custom JavaScript manipulation and event handling for the map view.
</p>
<p>
We also skip over the technical details of how the map data is encoded,
and assume the browser can convert the map data into images on screen.
The potential requirements in this section describe ways in which map viewers
enhance the normal experience of viewing a static image (e.g., <code>img</code> element)
in a web page.
<a href="#map-formats"></a> explores data structures and file formats.
</p>

<section id="map-viewers-capabilities-rendering">
<h3>Rendering base layers</h3>

<section id="capability-declarative-map" data-ucr-role="capability">
<h4>Embed an interactive map viewer, using HTML markup</h4>
<p>
This is the basic capability that is currently missing from the web:
the ability to use HTML code alone to add a map to a web page.
</p>
<p class="issue discussion" data-number="137">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
There are two types of web map implementations that currently come close:
embeddable iframe maps,
and HTML custom element wrappers to JS mapping libraries.
The limitation of iframes is that all configuration must be contained in the source URL,
instead of being able to use a proper markup API of attributes and child elements.
The limitation of custom elements, currently, is that they require extra polyfill JavaScript
in addition to the mapping library JavaScript.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
     Give details about what is/isn't supported in the dd element,
     starting with a link to one of the implementation levels.
     List full implementations first.
     Group implementations (multiple dt for the same dd) when they have the same support.
  -->
<dt>short-name-embed</dt>
<dt>short-name-api</dt>
<dd><a>full support|supported, with limitations|partial support|no support|not applicable</a>:
TO DO<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
TO DO: include img/picture, video, ...?
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
     Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
     Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
     whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
     See examples.
  -->
<p>
This functionality is the base <a data-ucr-role="conclusion">requirement</a> for a native HTML web map feature.
Being able to define a basic map using markup
would be one of the key benefit of having a built-in feature, compared to existing options.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
     Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
</ul>
</section>

<section id="capability-default-map" data-ucr-role="capability">
<h4>Generate a default map for a given area</h4>
<p>
Often, the website author does not want to specify the map data source or other details about the map;
they just want a generic wayfinding map of the area.
</p>
<p class="issue discussion" data-number="8">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The embeds and commercial APIs all provide default street maps
without the author needing to specify the map source.
In contrast, the more flexible APIs
must be combined with a separate map provider (e.g., OpenStreetMap).
</p>
<dl data-ucr-role="implementation-notes">

<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
this is the basic function for these widgets: give it a location, it will draw the map.
</dd>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd><a>no support</a>:
must be combined with a separate map provider.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
No non-map uses for generating a default street map.
But, there may be interest in displaying default maps as static images
in addition to using them within map widgets.
</p>

<h5>Related web specifications</h5>
<p>
…
</p>

<h5>Conclusion</h5>
<p>
This functionality is a highly valuable <a data-ucr-role="conclusion">enhancement</a>
for native web maps,
especially if it could be built on native platform features
that allow the users to download maps in advance for later use.
However, if user agents cannot integrate with a native operating system feature,
they would need to rely on a third-party service for the map data.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li>
<a data-ucr-role="tag" href="#author-simplicity"></a>
Many map services are either paid or require some form of authentication,
even for simple use cases such as this.
Having this capability be a browser feature
reduces complexity for most use cases.
</li>
<li>
<a data-ucr-role="tag" href="#author-independence"></a>
The vast majority of web maps currently utilize either third-party mapping libraries or third party tiles.
Web maps that self-host both library code and tiles avoid third-party dependencies,
but due to the resources required to self-host tilesets,
only a small percentage of map authors opt for this approach.
</li>
</ul>

</section>

<section id="capability-single-custom-image" data-ucr-role="capability">
<h4>Display an image file as a map layer</h4>
<p>
If a web author already has (or can generate on the server) a map
in a standard image format the browser can render — JPEG, PNG, SVG, etc. —
can the map viewer display it as a map layer?
Or will it need to be converted into a geospatial data format?
</p>
<p>
For most use cases, at least some additional metadata will be required,
to align the image pixels to the geographic coordinates of the map.
</p>
<p class="issue discussion" data-number="138">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The majority of the embed maps do not support custom image layers.
The API tools that do support this feature typically accept a layer source, attribution,
and the coordinate system to be used by the image layers,
which can be mapped to pixel units for more simple use cases.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>
</dd>
<dt>mapbox-embed</dt>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dd>
  <a>no support</a>: most embeds do not support this.
  Adding a custom image layer requires more configuration than supported by these tools.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
This capability is essential in order to provide support for non-map materials.
The ability to display non-georeferenced media like technical drawings,
schematics or archival material within a standardized viewer
has a wide variety of practical use cases.
</p>

<h5>Related web specifications</h5>
<p>
The <a data-cite="SVG2#">SVG</a> <code>image</code> element provides an example
of external image content being rendered into a specified rectangle within a coordinate system.
</p>
<p>
Similarly, the <a data-cite="HTML#the-canvas-element">HTML Canvas2D API</a> has a <code>drawImage()</code> method
for rendering a scaled and positioned copy of an external image within the canvas.
</p>
<h5>Conclusion</h5>
<p>
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
</ul>
</section>

<section id="capability-custom-map-tiles" data-ucr-role="capability">
<h4>Display a map using tile data from an author-specified web map service</h4>
<p>
A single image for an entire map layer is impractical on the web
for large, pan-able maps at good resolution.
For this reason, most web map services provide map data as <a>tilesets</a>.
Beyond any <a href="#capability-default-map">default map layer</a> that the viewer provides,
can it process tilesets as a custom map layer?
If so, in what form?
</p>
<p class="issue discussion" data-number="139">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All API tools support some form of this feature, whether it be in the more popular OpenStreetMap standard (often called XYZ), or the TMS standard. For most services, tiles can be accessed through a URL with the X, Y and Z parameters defined, where X and Y represent the tile coordinates (not to be confused with latitude and longitude), and Z represents the zoom level. One thing to note is that while Google Maps and the OpenStreetMap standard both count tiles from the upper left corner of the map, the TMS standard has the Y axis inverted, counting tiles from the bottom left, and some transformation may be needed when using certain tools with certain tilesets.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>
</dd>
<dt>tomtom-sdk</dt>
<dd>
  <a>no support</a>: Although TomTom supports <a>WMS</a> services (where the server can generate a single image file for custom map coordinates),
      it does not support <a>TMS</a> or other custom tile sources
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dd>
  <a>no support</a>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<p>
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li>
<a data-ucr-role="#author-extensibility"></a>
This capability is necessary for many advanced use cases.
</li>
</ul>

</section>

<section id="capability-no-js" data-ucr-role="capability">
<h4>Display a basic map without JavaScript</h4>
<p>
Users may disable JavaScript for security reasons,
or as part of a strategy to reduce data consumption.
In addition, JavaScript can fail because of network errors
or because of a parsing or runtime error in the code.
</p>
<p>
It is reasonable that web maps have reduced functionality without JavaScript.
But ideally, a basic map with text annotations and links should still work without it.
</p>
<p>
A natively-supported, declarative web map viewer would by definition have this capability.
</p>
<p class="issue discussion" data-number="32">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Our reference implementations are primarily JavaScript tools.
Many do not — by default — provide any features when JS is disabled or fails,
although a website author could build in fallbacks
by including links, images, or iframes in the markup
that are replaced when the script runs.
</p>
<p>
For built-in graceful degradation,
iframe embeds potentially offer the best experience,
but all of the reference tools do not support this by default,
the map author must add this feature themselves.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>google-maps-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>supported, with limitations</a>:
  these tools offer options to serve a static image without JavaScript,
  typically by joining together tiles when the map author passes in a center and zoom level parameter
  into a specific URL format.
  However, this is not the default fallback behavior for the embeds
  when JavaScript is turned off;
  adding a fallback image must be implemented as a custom feature.
</dd>
<dt>openstreetmap-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd><a>no support</a>:</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
To the extent that any capabilities of a map viewer are shared with other content,
having that capability work without JavaScript is a shared benefit.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li>
<a data-ucr-role="tag" href="#author-simplicity"></a>
As no tools include this by default,
supporting this capability would dramatically simplify the process of building progressively enhanced maps.
</li>
<li>
<a data-ucr-role="tag" href="#performance-data-savings"></a>
Supporting fallbacks for devices without JavaScript would allow users on poor connections
or those who intentionally disable JavaScript
to have a decent baseline experience.
</li>
<li>
<a data-ucr-role="tag" href="#consistency-progressive"></a>
This capability is fundamental to building progressively enhanced maps.
</li>
</ul>
</section>

<section id="use-case-preferred-language" data-ucr-role="use-case">
<h4>Display map content in a users preferred language</h4>
<p>

</p>
<p class="issue discussion" data-number="136">
Discuss this section on GitHub.
</p>
</section>

</section>

<section id="map-viewers-capabilities-vectors">
<h3>Vector features and overlays</h3>

<section id="capability-marker-points" data-ucr-role="capability">
<h4>Show pinpoint locations or custom markers on the map</h4>
<p>
A map marker is a small icon that marks a <a>point feature</a>.
Wayfinding maps often have extensive sets of icon markers
that identify different types of features.
In web maps, the pinpoint marker (a circle narrowing into a point at the bottom)
has become standard for identifying any location of interest.
</p>
<p class="issue discussion" data-number="140">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Almost all of the reference tools support map markers in some way.
While most embed tools include some kind of geocoder in order to
support address lookup, the tools typically utilize latitude and
longitude coordinates under the hood, and map authors can pass in
the coordinates to the URL or configuration object upon initialization.
</p>

<p>
The notable standout here is the Google Maps Embed.
Searching for a location by address  will return information
for a 'Place', each with its own ID and information such as
business hours, reviews, and etc. The ID, rather than latitude and longitude,
is passed into the iframe URL in order to bring up the additional
location information for that particular place.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: allows multiple user-specified pinpoint locations to be placed
</dd>
<dt>openstreetmap-embed</dt>
<dd><a>supported, with limitations</a>: only allows you to show a single marker on embedded maps
<dt>bing-maps-embed</dt>
<dd><a>no support</a>: allows for display of a general area but no map markers</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
If the map element were to support non-georeferenced images,
custom markers could be used as an annotation tool for
technical drawings and other similar media.
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-vector-features" data-ucr-role="capability">
<h4>Draw polygons or polylines as stylable, interactive vector graphics (separate from the image tiles)</h4>
<p>
Polygons and polylines are two of the most common types of map data features.
</p>
<p>
It is common on the web for vector map data to be pre-rendered
into raster image layers on the server.
However, if the vector feature is important for the web view,
drawing it as separate graphic object means it can be dynamically styled,
associated with labels or descriptions,
and the target of user events.
</p>
<p class="issue discussion" data-number="141">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The tools that support this capability primarily fall under the
API category. All of the API tools support the drawing of lines
and polygons by passing in coordinates into a JavaScript function.
Mapbox differs from the other implementations as it only accepts
files in the GeoJSON format. The embed tools lack support for this capability.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: polygons and polylines can be added and have styling applied to them.
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dd><a>no support</a>:</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
     Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
     Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
     whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
     See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
     Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-hyperlinks" data-ucr-role="capability">
<h4>Support hyperlinks from markers or vector features</h4>
<p>
For a map to be truly a part of the web,
it needs to be able to link to other web resources.
</p>
<p class="issue discussion" data-number="142">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The API tools all provide ways to bind event handlers to map features,
allow map authors to display additional information when a map feature
is clicked. While it is technically possible to to turn map features
into an external link by using JavaScript, this is not a very common
pattern as it may interfere with other user interactions such as panning
and it can produce markup that is not consistent with the functionality of the map.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: map markers and vector features can have popups
  that contain custom HTML, allowing the map author to display hyperlinks within the popups.
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dd><a>no support</a>:</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-attribution" data-ucr-role="capability">
<h4>Display map data attribution and links</h4>
<p>
Map data is subject to copyright,
and use of the maps on the web usually requires at least attribution,
and maybe links to terms of use.
Many map services also include links for end users to report errors.
</p>
<p class="issue discussion" data-number="143">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Standard practice in the reviewed web map tools
is to display this attribution in the lower right of the map widget.
For map viewers that provide their own map data,
the links and copyright is automatically generated.
For map frameworks that allow the developer to specify the map data source,
these "attribution control" values can be set in configuration.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dd><a>supported, with limitations</a>: attribution is automatically generated,
but it is not keyboard accessible.</dd>
</dl>
</section>

</section>

<section id="map-viewers-capabilities-locations">
<h3>Interpreting locations & map positions</h3>

<section id="capability-location-latlong" data-ucr-role="capability">
<h4>Select map view from latitude and longitude point</h4>
<p>
Latitude and longitude defines a point on the Earth's surface,
without requiring any further information.
For website content, latitude and longitude data
might come from photo or video metadata (from GPS-enabled cameras),
or it might be calculated by the author using map search services.
In a dynamic web app, latitude and longitude might be generated
from geolocation on the user's device.
</p>
<p class="issue discussion" data-number="144">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All the reference tools allow the website author
to display a specific location, defined by latitude and longitude,
from a map tile set.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>leaflet-api</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
setting a location by latitude and longitude is straightforward.
</dd>
<dt>open-layers-api</dt>
<dd><a>supported, with limitations</a>:
A location defined with longitude and latitude
<a href="https://openlayers.org/en/latest/doc/faq.html#why-is-my-map-centered-on-the-gulf-of-guinea-or-africa-the-ocean-null-island-">must be converted to the map tile coordinate system</a>,
but the API provides the conversion function.
</dd>
<dt>bing-maps-embed</dt>
<dd><a>partial support</a>: does not support markers for a single location, but it is possible to display a map centered around a particular latitude and longitude point with no marker</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
…
</p>

<h5>Related web specifications</h5>
<p>
The <a data-cite="geolocation-API" data-no-xref="">Geolocation API</a>
and <a data-cite="geolocation-sensor" data-no-xref="">Geolocation Sensor API</a>
expose the user's location using latitude and longitude data.
It should be possible to set the view on a web map using data returned from these APIs.
Both of these APIs use the [[[WGS84]]] as the technical definition
of longitude and latitude (consistent with most modern geospatial standards),
and a web map standard should use the same definition.
[[geolocation-API]][[geolocation-sensor]][[WGS84]]
</p>

<h5>Conclusion</h5>
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-location-address" data-ucr-role="capability">
<h4>Select map view from street address or place name</h4>
<p>
For many mapping use cases,
a website author won't have exact latitude and longitude values pre-calculated.
They'll have street addresses or place names
in a human-readable, localized format.
To convert these addresses or names into a point on a web map,
the web mapping service needs access to a Gazetteer search and corresponding databases.
</p>
<p class="issue discussion" data-number="145">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
The majority of reference tools support this functionality, either
through first party support or through popular plugins. This frequently
takes the form of a search form that returns a possible list of
options that the map author can select from. The Google Maps geocoder
is the gold standard amongst these implementations, as it
is more forgiving in terms of search format and provides better
support for different localizations than other alternatives.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: by default, these tools provide address search when setting up the map
</dd>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd><a>supported, with limitations</a>: the default libraries do not support this but there are a wide variety of geocoding plugins that support this capability.</dd>
<dt>bing-maps-embed</dt>
<dd><a>partial support</a>: does not support markers for a single location, but it is possible to display a map centered around a particular street address with no marker</dd>
</dl>
</section>

<section id="capability-tile-coordinate-systems" data-ucr-role="capability">
<h4>Display map tiles defined in various common coordinate systems</h4>
<p>
Most tiled image maps on the web use the Web Mercator
system of dividing map data into image tiles.
As the name suggests, this is based on the Mercator map projection,
with the addition of standard for dividing the map into tiles at different zoom levels.
</p>
<p>
Web Mercator is not appropriate for maps of polar regions,
where the Mercator projection distorts geography.
Other tileset coordinate systems have been defined specifically for polar maps.
In addition, many regions have well-established local map grid coordinate systems,
and being able to use the local grid means access to established map data sources.
</p>
<p>
The technological complexity of supporting different projections
depends on how many other capabilities are supported.
Tiling images doesn't require knowing how those images map to geographic coordinates.
But the tile boundaries and coordinate projection are needed
in order to draw marker points or vector features over the map.
And information about the tileset zoom levels is required
in order to dynamically load content on pan and zoom.
</p>
<p>
Combining map layers with different projections,
or otherwise converting one map projection to another view,
is a separate capability, discussed in <a href="#capability-reproject-maps"></a>.
</p>
<p class="issue discussion" data-number="14">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
With the Google Maps API, you are able to create custom rectilinear projections,
by passing in a bi-directional mapping between coordinate systems.
Leaflet.js supports the Equirectangular,
Elliptical Mercator and Web Mercator projections by default,
and you can use the external plugin
<a href="http://kartena.github.io/Proj4Leaflet/">Proj4Leaflet</a> to
support other projections.
OpenLayers also relies on <a href="https://github.com/proj4js/proj4js">Proj4</a>
in order to support other projections.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd>
  <a>supported, with limitations</a>: (as described above)
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>no support</a>: these embeds only support the Web Mercator projection.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-reproject-maps" data-ucr-role="capability">
<h4>Reproject map tile data into a new projection or globe view</h4>
<p>
Map image tiles are usually defined in Web Mercator
or other grid-based tile systems.
For large scale maps (of the globe or continents),
these reveal distortions created by the underlying projections.
Many different map projections exist to more fairly display the relative size and shapes of continents on a flat map.
In addition, within an interactive web environment,
it is possible to use projections which more directly represent the 3D globe
without trying to display it all at once,
letting user interaction rotate it to show parts of interest.
</p>
<p class="issue discussion" data-number="3">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
None of the reference tools support this feature.
<a href="#capability-tile-coordinate-systems">For the
tools that support alternative projections</a>, it is
possible to to work around this by reinitializing the map
in a different projection.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>no support</a>:
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-export-location" data-ucr-role="capability">
<h4>Save the location or export to other application</h4>
<p>
For the user, it is often useful to bookmark or save a location from a map,
separate from the website which included it.
The user may want to export the location to a GPS or native mapping application
so they can calculate directions to it.
</p>
<p class="issue discussion" data-number="146">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Most of the reference tools do not support this capability. Of the tested tools,
only OpenStreetMap offers the option to export a map location in a standard format.
</p>
<dl data-ucr-role="implementation-notes">
<dt>openstreetmap-embed</dt>
<dd><a>full support</a>:
  in addition to being able to generate and share a link or a map embed,
  it is possible to export the point locations as a geo URI.
</dd>
<dt>google-maps-embed</dt>
<dd><a>supported, with limitations</a>:
  a user is able to generate a link to the map that can be shared via a variety of methods,
  but there is no way to easily send this information to another application.
</dd>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>no support</a>:</dd>
</dl>
</section>

</section>

<section id="map-viewers-capabilities-user-navigation">
<h3>User navigation (pan & zoom)</h3>

<section id="capability-zoom" data-ucr-role="capability">
<h4>Zoom the map independently from the rest of the page</h4>
<p>
In addition to panning the view,
it is standard to allow the user to adjust the map scale:
zooming in to increase magnification (show finer detail),
zooming out to decrease magnification (show a wider area).
</p>
<p class="issue discussion" data-number="147">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>The following UI is standard across the reviewed map widgets:
</p>
<ul>
<li>Accessible buttons labelled with plus (+) and minus (-) signs zoom by steps.
</li>
<li>Mouse wheel movements (usually used to scroll the page) are captured
and converted into continuous zoom adjustments
(mouse scroll down becomes zoom out, mouse scroll up becomes zoom in).
Apple Mapkit JS inverts this popular convention.
Modifier keys (such as Ctrl for Google Maps and Shift for Apple Mapkit JS)
may be required so as not to intefere with default scroll behavior.
</li>
<li>Touch gestures for pinch zoom are used to zoom the map instead of the page.
</li>
</ul>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
      Give details about what is/isn't supported in the dd element,
      starting with a link to one of the implementation levels.
      List full implementations first.
      Group implementations (multiple dt for the same dd) when they have the same support.
  -->
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
(as described above)
<dt>mapbox-embed</dt>
<dd><a>supported, with limitations</a>: all of the above is supported, but the buttons do not have any focus styles</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
Localized zooming is used on the web for
charts and diagrams,
photographs (e.g., to examine details in a product photo, or for photo editing apps),
embedded documents (e.g., a PDF viewer),
and sometimes data tables.
</p>

<h5>Related web specifications</h5>
<p>
Zooms are often implemented using <a data-cite="css-transforms-1#">transforms</a>,
which defines the scale as a multiplicative factor compared to the normal size
(<code>scale(2)</code> for doubling the size, zooming in; <code>scale(0.5)</code> to zoom out by the same amount).
Scale transforms are paired with translations to create zoom and pan effects.
[[css-transforms-1]]
</p>
<p>
An alternative approach for describing zoom and pan
is used in <a data-cite="SVG2#">SVG</a> <code>viewBox</code> attribute
and in <a data-cite="media-frags#naming-space">spatial media fragments</a>.
In this system, the container element defines its own width and height (e.g., with CSS)
plus a target rectangle in the zoomable graphic's coordinate system
(x and y offset, plus width and height);
the user agent then zooms and pans the graphic
to display the target rectangle in the available space.
[[SVG2]][[media-frags]]
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps,
with other uses in the web platform.
A zoom specification will need to carefully consider all uses so it can be implemented consistently,
and should be coordinated with panning.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies --><i>To Do</i>
</li>
</ul>
</section>

<section id="capability-pan" data-ucr-role="capability">
<h4>Pan the map display</h4>
<p>
A key part of the interactivity of a web map widget is that the user can change the region displayed.
To pan the map is to shift the view horizontally or vertically,
so a different location is centered in the map display.
</p>
<p>
For mapping, panning is tightly linked with zooming and with dynamic loading of new content.
For this discussion, we've divided them into separate features
so that the costs, benefits, and non-mapping use cases can be assessed separately.
</p>
<p class="issue discussion" data-number="148">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>The following UI is standard among the reviewed map viewers:</p>
<ul>
<li>Drag the map view by clicking and holding a mouse.</li>
<li>Swipe the map view with touch gestures.</li>
</ul>
<p>The following UI is available in some viewers, but not all:</p>
<ul>
<li>Pan the map view with arrow keys.</li>
</ul>
<p>
Many of the maps lack a visible indication of keyboard focus for panning, and do not provide any other affordances
to indicate how keyboard panning should work.
</p>
<dl data-ucr-role="implementation-notes">
<dt>open-layers-api</dt>
<dt>bing-maps-api</dt>
<dd><a>full support</a>: for OpenLayers, a tabindex value must be added to the map container, but keyboard panning events are included natively</dd>
<dt>openstreetmap-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>tomtom-sdk</dt>
<dd><a>supported, with limitations</a>:
  Mouse, touch, and keyboard panning are supported; no keyboard focus indication
</dd>
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>partial support</a>:
  Mouse and touch panning only. Keyboard panning is possible on the google maps web application. Keyboard panning is
  activated when a specific region of the map is focused.
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
The standard panning interactions are also common on the web
for other JS-enhanced zoom and pan graphics
(e.g., a close up of a product photograph, a data chart).
Similar interactions may be used in some games,
or in navigation of large spreadsheets.
Creating a native way to trigger panning within a web layout
could help ensure consistent, accessible user experiences for panning.
</p>

<h5>Related web specifications</h5>
<p>
From a rendering perspective,
panning a map is very similar to scrolling a section of a CSS layout.
Important differences:
</p>
<ul>
<li>Although 2D scrolling is supported,
  the interaction usually emphasizes a primary reading axis.
  Panning is usually 2D, and may be conceptually diagonal as often as horizontal or vertical.
</li>
<li>The initial scroller view is usually at the start of the content (and “start” has meaning);
  an initially panning view is often in the middle, with panning in all directions possible.
</li>
<li>Scrollable content is often visually indicated by scrollbars
  (although it is now common to hide scrollbars until use).
</li>
<li>The user interactions are different for some input methods:
  mouse panning uses click and drag instead of mouse wheel for (primary-direction) scroll,
  keyboard panning only uses the arrows, not the space bar and page up/down keys (which trigger scroll in the
  primary axis).
</li>
</ul>
<p>
Panning interactions also overlap with the proposed
<a href="https://github.com/WICG/spatial-navigation">CSS spatial navigation</a> spec.
</p>
<p>
In web maps and many other applications,
panning effects are combined with <a href="#capability-zoom">zoom effects</a>;
for that reason, panning is often implemented using
CSS transforms or SVG <code>viewBox</code>,
which can also handle zoom.
[[css-transforms-1]][[SVG2]]
</p>

<h5>Conclusion</h5>
<p>
Panning the map is universally supported in JS web maps,
and is therefore a <a data-ucr-role="conclusion">requirement</a> for native web maps.
The relevant specification should be coordinated with CSS,
considering other use cases for panning on the web.
Thought is needed on how to make panning accessible to all users.
</p>
<ul>
<li><a data-ucr-role="tag">accessibility-info-needed</a>
  There are no established patterns for indicating that panning is possible.
</li>
<li><a data-ucr-role="tag">accessibility-potential</a>
  Keyboard accessibility is implemented poorly on the web;
  accessible browser implementations would be an improvement.
</li>
<li><a data-ucr-role="tag">implementation-incremental</a>
  Panning builds upon established, highly optimized scrolling mechanisms.
</li>
</ul>
</section>

<section id="capability-lazy-load" data-ucr-role="capability">
<h4>Load additional map tiles when they pan into view</h4>
<p>
For web maps using a tileset,
an initial series of tiles is loaded based on the current position of the map.
Tiles are lazily loaded,
and as such additional ones are loaded when they are panned into view.
This allows for a smaller initial payload and improved performance.
</p>
<p>
This capability is closely tied to the previous capability,
<a href="#capability-pan">panning the map display</a>.
</p>
<p class="issue discussion" data-number="149">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All of the reference tools support this capability as described.
Most tools show gray placeholder tiles while the additional tiles are being loaded,
but Google Maps shows a placeholder that is representative of the tile to be loaded
(ie. a blue tile for ocean tiles).
Bing maps takes a similar approach and shows a very low resolution tile,
until new tiles are fetched.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>:
</dd>
</dl>
</section>

<section id="capability-wrap-pan" data-ucr-role="capability">
<h4>Wrap/duplicate data tiles when panning around the globe</h4>
<p>
A web map is not subject to the same limitations of printed maps
and can be panned infinitely along an axis.
Tiles should be wrapped along at least one axis
in order to create a seamless panning experience.
</p>
<p class="issue discussion" data-number="150">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All of the reference tools support this capability.
Google Maps and Bing Maps cache the tiles once they are loaded,
but Leaflet, Open Street Map and the Open Layers API
re-fetch the same tiles as the user pans across the map.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as describe above)
</dd>
</dl>
</section>

<section id="capability-scale-adjust" data-ucr-role="capability">
<h4>Maintain reasonable scale of labels and lines when zooming</h4>
<p>
Zooming a map widget is different from
magnifying a regular image, or adjusting the overall browser zoom level;
the layout is magnified, but annotations such as text size and stroke width are not.
</p>
<p class="issue discussion" data-number="151">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>All of these tools scale their labels to match the zoom level,
but labels of smaller map features can be very small
and may not reflect the users text size preference.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
</dl>
</section>

<section id="capability-zoom-swap" data-ucr-role="capability">
<h4>Dynamically load different resolution map tile on zoom</h4>
<p>
A limited set of tiles is loaded initially
in order to send the user the smallest amount of data required to render the map.
When the zoom level is changed, additional tiles should be loaded and rendered seamlessly.
</p>
<p>
This capability is related to <a href="#capability-zoom">zoom the map display</a>.
</p>
<p class="issue discussion" data-number="152">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
All reference tools support this capability as described.
Google Maps differs from the other reference tools
in that it uses colored placeholder tiles
in order to provide an indication of the tile type before it has loaded.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>openstreetmap-embed</dt>
<dt>bing-maps-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
</dl>
</section>

<section id="capability-zoom-swap-vectors" data-ucr-role="capability">
<h4>Hide or show (and maybe dynamically load) vector features and labels on zoom</h4>
<p>
By default, web maps allow for the user to control the zoom level.
Certain vector features may not be perceivable at higher zoom levels,
and thus they should be hidden at higher zoom levels.
</p>
<p class="issue discussion" data-number="153">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>Support for this capability depends on the tileset,
but all of the reference tools implement this capability
with their default tilesets.</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-embed</dt>
<dt>google-maps-api</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>full support</a>: (as described above)
</dd>
</dl>
</section>

</section>

<section id="map-viewers-capabilities-custom-styling">
<h3>Custom styling</h3>

<section id="capability-styled-features" data-ucr-role="capability">
<h4>Apply custom styling to map markers and vector features</h4>
<p>
When available as an option for map authors,
custom styling should be set in a declarative way.
Map markers can be either raster or vector images,
with all relevant styling properties available to them.
Vector features should have a variety of presentational properties available to style them,
similar to how SVGs are styled on the web.
</p>
<p class="issue discussion" data-number="15">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Mapbox is unique amongst the reference tools as it offers a GUI
where styling can be applied to each vector feature.
Their style editor is extremely powerful,
and styles can be applied across particular zoom ranges, data ranges,
or even through conditional logic.
</p>
<p>
Behind the scenes, Mapbox's styles are stored in a JSON object
that conforms to their own <a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/">Style Specification</a>.
The TomTom SDK for Web accepts custom styles in the format of Mapbox's Style Specification.
</p>
<p>
For the other reference tools,
custom styles can be passed in as a JavaScript object on map initialization.
There is significant overlap
between the style properties used by these example tools and properties for formats like SVG,
such as 'stroke width', 'fill', 'opacity'.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>mapbox-embed</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>: (as described above)
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmaps-embed</dt>
<dt>bing-maps-embed</dt>
<dd><a>no support</a>
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-styled-controls" data-ucr-role="capability">
<h4>Apply custom styling to map controls</h4>
<p>
<!-- Description of how it should work & why it is useful to users/authors of maps. -->
</p>
<p>
This capability — custom styling —
is separate from the ability of the author to create complete custom controls
which then control the map viewer using a client-side API.
</p>
<p class="issue discussion" data-number="154">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Only Leaflet.js and OpenLayers provide a method to style map controls freely.
Because these tools are JavaScript libraries and not iframe embeds,
their controls can be styled by writing CSS that overrides the default styling.
TomTom SDK inherits this capability due to it being a wrapper over Leaflet.js.
</p>
<p>
The Google Maps API provides limited options when it comes to styling map controls.
The map author has the ability to set which form the controls take (dropdown or horizontal bar),
and set the position of the controls.
</p>

<dl data-ucr-role="implementation-notes">
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dd><a>full support</a></dd>
<dt>google-maps-api</dt>
<dd><a>supported, with limitations</a></dd>
<dt>google-maps-embed</dt>
<dt>openstreetmaps-embed</dt>
<dt>bing-maps-embed</dt>
<dt>mapbox-embed</dt>
  <dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>no support</a>:
  <!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

<section id="capability-custom-controls" data-ucr-role="capability">
<h4>Toggle whether default controls are displayed</h4>
<p>
Custom styling isn't always enough;
sometimes an author wants to completely replace the default control buttons.
Replacing the full functionality of the controls requires a
<a href="#client-apis">client-side API</a>, discussed separately.
This capability focuses solely on the ability to declaratively control
whether or not the web browser includes on-screen controls by default.
</p>
<p class="issue discussion" data-number="16">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Amongst the reference tools that support this capability,
toggling the visibility of default controls is as simple as
setting a boolean in a configuration object.
</p>
<dl data-ucr-role="implementation-notes">
<dt>google-maps-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom-sdk</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd>
  <a>full support</a>: (as described above)
</dd>
<dt>mapbox-embed</dt>
<dd>
  <a>partial support</a>: you can toggle controls for the HTML slippy map, but not maps created in the more robust Mapbox Studio editor.
</dd>
<dt>google-maps-embed</dt>
<dt>openstreetmaps-embed</dt>
<dt>bing-maps-embed</dt>
<dd><a>no support</a>:
  <!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
      Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
      Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
      whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
      See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
      Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>

</section>

</section>

<section id="client-apis">
<h2>Client-side Mapping API Capabilities</h2>
<p>
Client-side Mapping APIs (application programming interfaces)
allow website developers to create customized map viewers,
or other geographic applications.
Existing APIs are JavaScript libraries that offer
ready-to-use functions for fetching or rendering parts of a map,
or for manipulating a map-viewer widget.
A built-in web map solution would need to expose similar DOM APIs to JavaScript code.
</p>

<section id="client-apis-creation">
<h3>Creating maps and map components</h3>
<section id="capability-create-initialise-and-display-a-map" data-ucr-role="capability">
<h4>Create, initialise, and display a map</h4>
<p>
This is the starting point for all API usage.
</p>
<p class="issue discussion" data-number="55">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Implementations differ in how much is expected of the
developer wishing simply to initialise and display a map.
Those APIs that are tightly bound to a single source of
mapping data tend to provide a single method call with
options for configuration, whereas APIs that are data-
provider-agnostic at least require initialisation of data
sources in addition.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom</dt>
<dt>d3-geographies-api</dt>
<dd>
<p><a>full support</a>:
Google, Bing, MapKit and TomTom  allow straightforward creation of a map
with configuration options.
</p>
<p>
Leaflet, OpenLayers, and MapBox require explicit construction of objects defining the map layers
and viewport, with sensible defaults for creation of, for example, a map showing OpenStreetMap tiles
in a standard [[[WGS84]]] projection.
This provides added flexibility, at the expense of increasing the complexity of code that uses these libraries.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
Leaflet, OpenLayers, and MapBox allow for the creation of layers displaying non-geographical imagery.
</p>

<h5>Related web specifications</h5>
<p>
<a data-cite="HTML" data-no-xref="">HTML</a> specifies a number of aspects of elements
that embed media in a web page and expose JavaScript APIs to enable interaction and dynamic configuration.
</p>
<p>
The <a data-cite="DOM" data-no-xref="">DOM</a> provides interfaces for creating
HTML elements, which are what these implementations are using under the hood.
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>
<p>
[[[DOM]]] [[[HTML]]]
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
Incorporating this functionality of existing map libraries in HTML would benefit users
by reducing download size and time to interactivity. Web developers would benefit from
being able to program against a standard interface.
</p>
<p>However, it is to be expected that a native HTML web map element would be constructed
and initialised via existing DOM interfaces such as <var>document.createElement</var>
and <var>DOMElement.insertAdjacentHTML</var>. Additional aspects of the map element's
configuration might be achieved either through existing <var>DOMElement</var> interfaces
such as <var>setAttribute</var>, or through element-specific attributes and methods;
<i>cf.</i> the attributes and methods of the <var>HTMLMediaElement</var>.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-add-marker-or-multiple-markers-map" data-ucr-role="capability">
<h4>Add a marker or multiple markers to a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="56">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd><dt>open-layers-api</dt>
<dd><a>supported, with limitations</a>:
<!-- details about what is/isn't supported -->
</dd><dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
Incorporating this functionality of existing map libraries in HTML would benefit users
by reducing download size and time to interactivity. Web developers would benefit from
being able to program against a standard interface.
</p>
<p>However, it is to be expected that a native HTML web map element would be constructed
and initialised via existing DOM interfaces such as <code>document.createElement</code>
and <code>DOMElement.insertAdjacentHTML</code>. Additional aspects of the map element's
configuration might be achieved either through existing <var>DOMElement</var> interfaces
such as <var>setAttribute</var>, or through element-specific attributes and methods;
<i>cf.</i> the attributes and methods of the <var>HTMLMediaElement</var>.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-implement-a-custom-control" data-ucr-role="capability">
<h4>Implement a custom control</h4>
<p>
A custom control is a user interface element that is
integrated closely with the map's own user interface, and is
under the control of the map once it has ben added.
</p>
<p class="issue discussion" data-number="57">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
A custom control is a JavaScript object or a DOM element
that satisfies the API's requirements for it to be
integrated with the map.
Those requirements vary across APIs.
Generally, it is expected that a single DOM element
containing whatever other elements constitute the control UI
will be provided by the control.
In some cases the DOM element is passed to the API directly;
in others, a JavaScript object is passed to the API, which
is required to implement a method that returns the control's
containing DOM element.
Styling of the elements within the control is the
responsibility of the implementor.
</p>
<p>
Assuming the API requirements are satisfied, the behaviour
and rendering of the control are then the responsibility of
the implementation.
Typically, a custom control will listen to events from the
DOM, or the map, or both.
In response to those events, it will then update the state
of the map, update its own representation, or both.
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dd><a>full support</a>:
These APIs all define requirements for a JavaScript object or DOM element
to be able to be used as a custom control.
</dd>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>supported, with limitations</a>:
Items having the form and behaviour of custom controls can
be implemented in the form of overlays, but there is no facility for
distinguishing such controls from other overlays.
</dd>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->

<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-add-control-map" data-ucr-role="capability">
<h4>Add a control to a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="58">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>tomtom</dt>
<dt>d3-geographies-api</dt>
<dd>
<p><a>full support</a>:
Google, Bing, MapKit and TomTom  allow straightforward creation of a map
with configuration options.
</p>
<p>
Leaflet, OpenLayers, and MapBox require explicit construction of objects defining the map layers
and viewport, with sensible defaults for creation of, for example, a map showing OpenStreetMap tiles
in a standard [[[WGS84]]] projection.
This provides added flexibility, at the expense of increasing the complexity of code that uses these libraries.
</p>
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
Leaflet, OpenLayers, and MapBox allow for the creation of layers displaying non-geographical imagery.
</p>

<h5>Related web specifications</h5>
<p>
<a data-cite="HTML" data-no-xref="">HTML</a> specifies a number of aspects of elements
that embed media in a web page and expose JavaScript APIs to enable interaction and dynamic configuration.
</p>
<p>
The <a data-cite="DOM" data-no-xref="">DOM</a> provides interfaces for creating
HTML elements, which are what these implementations are using under the hood.
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>
<p>
[[[DOM]]] [[[HTML]]]
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-remove-control-map" data-ucr-role="capability">
<h4>Remove a control from a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="59">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-add-layer-map" data-ucr-role="capability">
<h4>Add a layer to a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="61">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dd><a>supported, with limitations</a>:
<!-- details about what is/isn't supported -->
</dd><dt>apple-mapkit-js-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd><dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-define-data-source-tile-layer" data-ucr-role="capability">
<h4>Define a data source for a tile layer</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="74">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-create-an-overlay-defined-by-vector-data" data-ucr-role="capability">
<h4>Create an overlay defined by vector data</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="155">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-create-an-overlay-defined-by-heatmap-data" data-ucr-role="capability">
<h4>Create an overlay defined by heatmap data</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="156">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-remove-layer-map" data-ucr-role="capability">
<h4>Remove a layer from a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="62">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dd><a>supported, with limitations</a>:
<!-- details about what is/isn't supported -->
</dd><dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-display-layer-map" data-ucr-role="capability">
<h4>Display a layer on a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="63">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>supported, with limitations</a>:
<!-- details about what is/isn't supported -->
</dd><dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-hide-layer-map" data-ucr-role="capability">
<h4>Hide a layer on a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="64">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dd><a>supported, with limitations</a>:
<!-- details about what is/isn't supported -->
</dd><dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-specify-style-map" data-ucr-role="capability">
<h4>Specify the style of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="65">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-determine-current-style-map" data-ucr-role="capability">
<h4>Determine the current style of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="66">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>
</section>

<section id="client-apis-map-viewport">
<h3>Controlling the displayed map view and responding to user actions</h3>

<section id="capability-get-bounds-map" data-ucr-role="capability">
<h4>Get the bounds of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="60">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>full support</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-pan-map-or-re-centre-map" data-ucr-role="capability">
<h4>Pan a map or re-centre a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="67">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-zoom-map-in-or-out" data-ucr-role="capability">
<h4>Zoom a map in or out</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="68">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-subscribe-map-move-events" data-ucr-role="capability">
<h4>Subscribe to map move events</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="69">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-subscribe-map-zoom-events" data-ucr-role="capability">
<h4>Subscribe to map zoom events</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="70">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-subscribe-marker-selection-events" data-ucr-role="capability">
<h4>Subscribe to marker selection events</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="71">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-change-bearing-map" data-ucr-role="capability">
<h4>Change the bearing of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="72">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-reset-bearing-map" data-ucr-role="capability">
<h4>Reset the bearing of a map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="73">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-move-the-map-to-display-a-given-location" data-ucr-role="capability">
<h4>Move the map to display a given location</h4>
<p>
An API should support allowing the map to be moved to
display a given location.
</p>
<p class="issue discussion" data-number="157">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-pan-and-zoom-to-bounding-box" data-ucr-role="capability">
<h4>Pan and zoom a map so as to completely show the area covered by a given bounding box</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="158">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-animate-the-re-centering-of-the-map-view" data-ucr-role="capability">
<h4>Animate the re-centering of the map view</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="159">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-animate-the-zooming-of-the-map" data-ucr-role="capability">
<h4>Animate the zooming of the map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="160">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

<section id="capability-animate-the-re-centering-of-the-map" data-ucr-role="capability">
<h4>Animate the re-centering of the map</h4>
<p>
Description to follow
</p>
<p class="issue discussion" data-number="161">
Discuss this section on GitHub.
</p>

<h5>Existing implementations</h5>
<p>
Existing implementation support:
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
Give details about what is/isn't supported in the dd element,
starting with a link to one of the implementation levels.
List full implementations first.
Group implementations (multiple dt for the same dd) when they have the same support.
-->
<dt>google-maps-api</dt>
<dt>bing-maps-api</dt>
<dt>apple-mapkit-js-api</dt>
<dt>mapbox-gl-api</dt>
<dt>leaflet-api</dt>
<dt>open-layers-api</dt>
<dt>d3-geographies-api</dt>
<dd><a>not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
ToDo
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
See examples.
-->
<p>
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
<!-- short summary of how the tag applies -->
</li>
</ul>
</section>

</section>
</section>

<section id="map-formats">
<h2>Map Data Formats for Map Viewers</h2>
<p>
Many different types of spatial data can be integrated in a web map:
satellite imagery,
cartographic representations of roads and terrain,
3D building profiles,
pinpoint locations with annotated descriptions,
route directions or other polyline paths,
and more.
Many standard and proprietary formats exist to describe this data.
</p>
<p>
A built-in web map viewer will need to work with spatial data
that is already available from web servers,
or that can be provided with minor server upgrades.
</p>

<section id="map-formats-vector">
<h3>Vector feature data formats</h3>

</section>

<section id="map-formats-projections-crs">
<h3>Map projections and coordinate reference systems</h3>

</section>

<section id="map-formats-server-apis">
<h3>Server APIs</h3>

</section>
</section>

<section id="requirements">
<h2>Summary of Requirements</h2>
<p>
<i>To Do: finish the script to generate a summary table from the annotated markup.</i>
</p>
</section>

<section class="appendix" id="issue-summary">
<h2>Open Issues</h2>
<p>
We are tracking issues on <a href="https://github.com/Maps4HTML/HTML-Map-Element-UseCases-Requirements/issues">Github</a>.
</p>
</section>

<section class='appendix'>
<h2>Acknowledgments</h2>
</section>


<script id="preprocess" class="remove">
;(()=>{/* closure */

const slugify = (s) => s.toLowerCase().replace(/[\W_]+/g, "-");
const uniqueValues = (array) => Array.from(new Set(array));
function dictFromArray(array, idProp="id") {
  return array.reduce((dict, item)=>(dict[item[idProp]]=item, dict), {});
}

const htmlFragmentFromString = (s, contextNode=document.body) => {
  let r = document.createRange();
  r.selectNode(contextNode);
  return r.createContextualFragment(s);
}

function processTagDfn(node) {
  let tagType = (node.getAttribute("data-ucr-tag-type")||"unknown").trim();
  node.innerHTML = `<span class="tag-span tag-${tagType}">${node.innerHTML}</span>`;
  let tagNode = node.firstChild;
  return { dfnNode: node, tagNode, tagType, id: node.id };
}
let tagDfns = [...document.querySelectorAll("[data-ucr-role='tag-dfn']")]
  .map( processTagDfn );
let tagDfnDict = dictFromArray(tagDfns);
let conclusionDfns = [...document.querySelectorAll("[data-ucr-role='conclusion-dfn']")]
  .map( processTagDfn );
let conclusionDict = dictFromArray(conclusionDfns);

function findSectionTitle(node) {
  let heading = node.querySelector("h2,h3,h4,h5,h6")
        || node.firstElementChild || node;
  return heading.textContent.trim();
}
function processUseCase(node) {
  let name = findSectionTitle(node);
  let id = node.id || (node.id = "use-case-" + slugify(name));
  return { node, name, id };
}
function processCapability(node) {
  let name = findSectionTitle(node);
  let id = node.id || (node.id = "capability-" + slugify(name));

  let conclusionNode = node.querySelector("[data-ucr-role='conclusion']");
  let conclusion = conclusionNode?
    (conclusionNode.getAttribute("data-lt") || conclusionNode.textContent)
    : "undecided";
  if (conclusionNode) processTag(conclusionNode, conclusionDict);

  // extract the “supported use cases” & generate cross references
  const capabilityUseCasesList = node.querySelector("ul[data-ucr-role='capability-uses']");
  if (capabilityUseCasesList) {
    const supportedUseCaseLinks = [...document.querySelectorAll(`[data-ucr-role='required-capabilities'] [href='#${id}']`)];
    supportedUseCaseLinks.forEach((link) => {
      const useCase = link.closest("[data-ucr-role='use-case']");
      const a = document.createElement('a');
      a.href = `#${useCase.id}`;
      const li = document.createElement('li');
      li.appendChild(a);
      capabilityUseCasesList.appendChild(li);
    });
  }

  return { node, name, id, conclusion,
           tags: [], implementations: {} };
}
function processTag(node, dict) {
  let tagDfnId = node.hash? node.hash.replace(/^#/, "")
                       : node.textContent.trim();
  let tagDfn = dict[tagDfnId];
  if (!tagDfn) return null;
  if (!node.hash) node.href = "#" + tagDfnId;
  node.textContent = "";
  node.appendChild( tagDfn.tagNode.cloneNode(true) );
  return tagDfn;
}

let useCases = [...document.querySelectorAll("[data-ucr-role='use-case']")]
  .map( processUseCase );

let capabilities = [...document.querySelectorAll("[data-ucr-role='capability']")]
  .map( processCapability );

capabilities.forEach((capability)=>{
  let tags = [...capability.node.querySelectorAll("[data-ucr-role='tag']")]
    .map( (node)=>processTag(node, tagDfnDict) );
  capability.tags = uniqueValues(tags).filter(Boolean);
});

/* TODO, build a summary table from all the capability data */

document.documentElement.classList.add("processed");
})();/* closure */
</script>

<template id="tag-dfn-template" style="display: none" class="remove">
<!-- Markup template for adding a new tag to the guiding principles section.
     The `id` is essential & is what will be used to link to the tag.-->
<li>
<dfn id=""
     data-ucr-role="tag-dfn"
     data-ucr-tag-type="good|caution|bad">Category: description</dfn>
indicates <!-- longer description -->
</li>
</template>

<template id="use-case-template" style="display: none" class="remove">
<!-- Markup template for each use case.
     Attributes starting with `data-ucr-` are used in the script.
  -->
<section id="use-case-***" data-ucr-role="use-case">
<h4><!-- Goal that user/author is trying to achieve --></h4>
<p>
<!-- Short (1-3 paragraph) description, with details on who/why this goal is important -->
</p>
<p>
See <a href="examples/#(add a new file for each use case)" target="examples">examples of <!-- description --></a>
as implemented by the reference JavaScript tools.
</p>
<p class="issue discussion" data-number="(GH issue number for discussion)">Discuss this section on GitHub.</p>

<h5>Required capabilities</h5>
<ul data-ucr-role="required-capabilities">
<li><a href=""></a></li>
</ul>
</section>
</template>

<template id="capability-template" style="display: none" class="remove">
<!-- Markup template for each capability, include as many as required for each use case -->
<section id="capability-***" data-ucr-role="capability">
<h4><!-- Action that is/should be possible --></h4>
<p>
<!-- Description of how it should work & why it is useful to users/authors of maps. -->
</p>
<p class="issue discussion" data-number="(GH issue number for discussion)">Discuss this section on GitHub.</p>

<h5>Existing implementations</h5>
<p>
<!-- Summarize how this capability is implemented in the reference tools,
    including common patterns, notable differences, and any limitations.
    Specific details for each should be given in the list that follows.
    Wherever possible, include the implementation in the example file for the use case -->
</p>
<dl data-ucr-role="implementation-notes">
<!-- Use dt elements to name the implementation, using the id string to create an auto-link.
     Give details about what is/isn't supported in the dd element,
     starting with a link to one of the implementation levels.
     List full implementations first.
     Group implementations (multiple dt for the same dd) when they have the same support.
  -->
<dt>short-name-embed</dt>
<dt>short-name-api</dt>
<dd><a>full support|supported, with limitations|partial support|no support|not applicable</a>:
<!-- details about what is/isn't supported -->
</dd>
</dl>

<h5>Supported use cases</h5>
<ul data-ucr-role="capability-uses"><!-- auto-generated from use case required capabilities --></ul>

<h5>Uses beyond mapping</h5>
<p>
<!-- What other web content could use this specific capability? Be brief but specific. -->
</p>

<h5>Related web specifications</h5>
<p>
<!-- Any existing/proposed specs that address similar needs or otherwise interact.
     Include links with proper ReSpec references. -->
</p>

<h5>Conclusion</h5>
<!-- Cost, benefits, and recommendation on whether this should be a requirement.
     Should include an `<a>` element with attribute `data-ucr-role="conclusion"`
     whose text content or `data-lt` value matches one of the conclusions (requirement, enhancement, impractical, undecided).
     See examples.
  -->
<p>
<!-- This functionality is a <a data-ucr-role="conclusion">requirement</a> for modern web maps. -->
<!-- This functionality could be added to <a data-ucr-role="conclusion" data-lt="enhancement">enhance</a> native web maps in the future. -->
<!-- This capability is <a data-ucr-role="conclusion">impractical</a> for a built-in browser implementation. -->
Based on the limited data, we are <a data-ucr-role="conclusion">undecided</a> about whether this should be a requirement.
</p>
<ul data-ucr-role="conclusion-notes">
<!-- bullet-point notes summarizing implementation details / blocking issues.
     Add tags to the start of a point with an empty `<a data-ucr-role="tag"></a>` where the text content or href matches a tag `id` value. -->
<li><a data-ucr-role="tag" href=""></a>
  <!-- short summary of how the tag applies -->
</li>
</ul>

</section>
</template>

</body>
</html>
